import os
import threading
from sys import path

import requests
from enum import Enum
from typing import Optional, Any

from android_utils import log, run_on_ui_thread
from base_plugin import BasePlugin, HookResult, HookStrategy
from client_utils import get_last_fragment
from ui.alert import AlertDialogBuilder
from ui.bulletin import BulletinHelper
from ui.settings import Selector, Input

from java.io import File

from org.telegram.messenger import ApplicationLoader

__id__ = "reswag"
__name__ = "reSwaga"
__description__ = "свага💤"
__icon__ = "remusic/0"
__version__ = "1.0.0"
__author__ = "@reNightly, @qmrrchh"
__min_version__ = "11.12.1"


PLATFORM_EXTENSION = "swag_"


def logcat(message):
    log(f"[{__id__}] {message}")


def show_error(message):
    BulletinHelper.show_error(f"[{__name__}] {message}")


def _get_temp_dir() -> Optional[File]:
    try:
        base_dir = os.path.dirname(os.path.abspath(__file__))
        if not base_dir:
            return None
        temp_dir = File(base_dir)
        logcat(f"dir {temp_dir.getAbsolutePath()}")
        if not temp_dir.exists() and not temp_dir.mkdirs():
            return None
        return temp_dir
    except Exception as e:
        logcat(f"Error getting/creating temp directory: {e}")
        return None


class Track:
    def __init__(
            self,
            active: bool,
            track_id: int = None,
            title: str = None,
            artist: list = None,
            album: str = None,
            thumb: str = None,
            duration: int = None,
            progress: int = None,
            link: str = None,
            download_url: str = None,
    ):
        self.active = active
        self.track_id = track_id
        self.title = title
        self.artist = artist
        self.album = album
        self.thumb = thumb
        self.duration = duration
        self.progress = progress
        self.link = link
        self.download_url = download_url


class Platform(Enum):
    NotSelected = 0
    Spotify = 1
    YandexMusic = 2
    SoundCloud = 3

    @classmethod
    def has_value(cls, value):
        return value in cls._value2member_map_


class BasePlatform:
    def __init__(self, value: str):
        self.poller_enabled: bool = False
        self.now_track: Optional[Track] = None

        if value:
            self.value: str = value
        else:
            logcat("Value is none.")

    def get_track(self) -> Optional[Track]:
        pass

    def poller(self):
        pass

    def start_poller(self):
        if not self.poller_enabled:
            self.poller_enabled = True
            threading.Thread(target=self.poller, daemon=True).start()
        else:
            logcat("Poller already started.")

    def stop_poller(self):
        if self.poller_enabled:
            self.poller_enabled = False
        else:
            logcat("Poller not started for stopping.")


def get_platform_name(platform: Platform) -> Optional[str]:
    if platform == Platform.NotSelected:
        return None
    elif platform == Platform.Spotify:
        return PLATFORM_EXTENSION + "spotify"
    elif platform == Platform.YandexMusic:
        return PLATFORM_EXTENSION + "ym"
    elif platform == Platform.SoundCloud:
        return PLATFORM_EXTENSION + "sc"
    else:
        return None


class ReSwagaPlugin(BasePlugin):
    def __init__(self):
        super().__init__()
        if not self.enabled: return
        self.platform: Optional[BasePlatform] = None
        self.spinner: Optional[AlertDialogBuilder] = None

    def on_plugin_load(self):
        if not self.enabled: return
        self.add_on_send_message_hook()
        _get_temp_dir()
        self.update_platform_object(self.get_setting("selected_platform", 0))
        logcat(f"plugin loaded")

    def on_plugin_unload(self):
        logcat(f"plugin unloaded")

    def create_settings(self):
        selected_platform = self.get_setting("selected_platform", 0)
        return [
            Selector(
                key="selected_platform",
                text="платформа",
                items=["Не выбрано", "Spotify", "Yandex.Music", "Soundcloud"],
                default=0,
                on_change=lambda new_value: self.update_platform_object(new_value)
            ),
            Input(
                key="value",
                text="token"
            ) if selected_platform != int(Platform.NotSelected.value) else None,
        ]

    def on_send_message_hook(self, account: int, params: Any):
        text = params.message

        if text == ".now":
            platform = self.get_setting("selected_platform", 0)
            if platform == 0 or self.platform is None:
                BulletinHelper.show_error("You can't use command without selected platform.")
                return HookResult(strategy=HookStrategy.CANCEL)

            track = self.platform.get_track()
            if track is None:
                BulletinHelper.show_error("track not found")
                return HookResult(strategy=HookStrategy.CANCEL)

            params.message = f"{track.artist}: {track.title}"
            return HookResult(strategy=HookStrategy.MODIFY, params=params)
        else:
            return HookResult(strategy=HookStrategy.DEFAULT)

    def update_platform_object(self, new_platform: int):
        if new_platform == int(Platform.NotSelected.value):
            self.platform = None

        elif new_platform == int(Platform.Spotify.value):
            try:
                from swag_spotify import Spotify
                self.platform = Spotify()
            except ModuleNotFoundError as e:
                threading.Thread(target=self.download_platform, args=(Platform.Spotify,)).start()
                logcat(f"Failed to import Spotify. ({e})")

        elif new_platform == int(Platform.YandexMusic.value):
            try:
                from swag_ym import YandexMusic
                token = self.get_setting("value", "none")
                self.platform = YandexMusic(token)
            except ModuleNotFoundError as e:
                threading.Thread(target=self.download_platform, args=(Platform.YandexMusic,)).start()
                logcat(f"Failed to import YandexMusic. ({e})")

        elif new_platform == int(Platform.SoundCloud.value):
            try:
                from swag_sc import SoundCloud
                self.platform = SoundCloud()
            except ModuleNotFoundError as e:
                threading.Thread(target=self.download_platform, args=(Platform.SoundCloud,)).start()
                logcat(f"Failed to import SoundCloud. ({e})")

        else:
            logcat(f"Unknown platform ({new_platform})")

    def download_platform(self, platform: Platform):
        run_on_ui_thread(lambda : self.show_spinner())
        name = get_platform_name(platform)
        if name is None:
            logcat("Platform name is none.")
            show_error("Platform name not found.")
            run_on_ui_thread(lambda: self.dismiss_spinner())
            return

        name += ".py"
        temp = _get_temp_dir()
        if temp is None:
            logcat("Platform temp dir is none.")
            show_error("Temp directory not found.")
            run_on_ui_thread(lambda: self.dismiss_spinner())
            return

        file_path = os.path.join(temp.getAbsolutePath(), name)
        logcat(file_path)
        url = f"https://raw.githubusercontent.com/cherryymerryy/reSwaga/main/{name}"

        try:
            logcat(f"Downloading {name}...")
            response = requests.get(url, timeout=15)
            response.raise_for_status()
            content = response.content

            if content:
                with open(file_path, "wb") as f:
                    f.write(content)
                logcat(f"Successfully downloaded {name}.")
            else:
                logcat(f"Downloaded empty file for {name}.")

        except requests.exceptions.HTTPError as e:
            show_error(f"Failed to download {name}. Server returned error: {e}")
            logcat(f"Failed to download {name}. Server returned error: {e}")
        except requests.exceptions.RequestException as e:
            show_error(f"Failed to download {name} due to a network error: {e}")
            logcat(f"Failed to download {name} due to a network error: {e}")
        except IOError as e:
            show_error(f"Failed to save {name}. Permission or disk error: {e}")
            logcat(f"Failed to save {name}. Permission or disk error: {e}")
        except Exception as e:
            show_error(f"An unexpected error occurred while downloading {name}: {e}")
            logcat(f"An unexpected error occurred while downloading {name}: {e}")

        run_on_ui_thread(lambda: self.dismiss_spinner())

    def show_spinner(self):
        fragment = get_last_fragment()
        ctx = fragment.getParentActivity() if fragment else ApplicationLoader.applicationContext
        if ctx is None: return

        self.spinner = AlertDialogBuilder(ctx, AlertDialogBuilder.ALERT_TYPE_SPINNER)
        self.spinner.set_cancelable(False)
        self.spinner.set_canceled_on_touch_outside(False)
        self.spinner.set_on_cancel_listener(None)
        self.spinner.create()
        self.spinner.show()

    def dismiss_spinner(self):
        if self.spinner and self.spinner.get_dialog() and self.spinner.get_dialog().isShowing():
            self.spinner.dismiss()

        self.spinner = None
