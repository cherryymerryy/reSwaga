"""



                            –î–ò–°–ö–õ–ï–ô–ú–ï–†

–ï—Å–ª–∏ –ø—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏ —Å–≤–æ–µ–≥–æ –ø–ª–∞–≥–∏–Ω–∞ –≤—ã —Ä–µ—à–∏–ª–∏ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –≥–æ—Ç–æ–≤—ã–µ –∫–æ–¥–æ–≤—ã–µ —Ä–µ—à–µ–Ω–∏—è
–Ω–∞—à–µ–≥–æ –ø–ª–∞–≥–∏–Ω–∞ —É —Å–µ–±—è, —Ç–æ –Ω–µ –∑–∞–±—É–¥—å—Ç–µ —É–ø–æ–º—è–Ω—É—Ç—å –≤ –æ–ø–∏—Å–∞–Ω–∏–∏ —Å–≤–æ–µ–≥–æ –ø–ª–∞–≥–∏–Ω–∞
–∫–∞–Ω–∞–ª @MeeowPlugins –≤ –∫–∞—á–µ—Å—Ç–≤–µ –∫—Ä–µ–¥–∏—Ç–æ–≤ –∑–∞ –ø–æ–º–æ—â—å –≤ —Ä–∞–∑—Ä–∞–±–æ—Ç–∫–µ –ø–ª–∞–≥–∏–Ω–∞. –°–ø–∞—Å–∏–±–æ


                  ‚£æ‚°á‚£ø‚£ø‚°á‚£æ‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£Ñ‚¢ª‚£¶‚°Ä‚†Å‚¢∏‚°å‚†ª‚£ø‚£ø‚£ø‚°Ω‚£ø‚£ø
                  ‚°á‚£ø‚†π‚£ø‚°á‚°ü‚†õ‚£â‚†Å‚†â‚†â‚†ª‚°ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£¶‚£Ñ‚°â‚†Ç‚†à‚†ô‚¢ø‚£ø‚£ù‚£ø
                  ‚†§‚¢ø‚°Ñ‚†π‚£ß‚£∑‚£∏‚°á‚†Ñ‚†Ñ‚†≤‚¢∞‚£å‚£æ‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£∂‚£§‚£§‚°Ä‚†Ñ‚†à‚†ª‚¢Æ
                  ‚†Ñ‚¢∏‚£ß‚†Ñ‚¢ò‚¢ª‚£ø‚°á‚¢Ä‚£Ä‚†Ñ‚£∏‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ß‚°Ä‚†Ñ‚¢Ä
                  ‚†Ñ‚†à‚£ø‚°Ü‚¢∏‚£ø‚£ø‚£ø‚£¨‚£≠‚£¥‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£Ø‚†ù‚†õ‚†õ‚†ô‚¢ø‚°ø‚†É‚†Ñ‚¢∏
                  ‚†Ñ‚†Ñ‚¢ø‚£ø‚°Ä‚£ø‚£ø‚£ø‚£æ‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£∑‚£ø‚£ø‚£ø‚£ø‚°æ‚†Å‚¢†‚°á‚¢Ä
                  ‚†Ñ‚†Ñ‚¢∏‚£ø‚°á‚†ª‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£è‚£´‚£ª‚°ü‚¢Ä‚†Ñ‚£ø‚£∑‚£æ
                  ‚†Ñ‚†Ñ‚¢∏‚£ø‚°á‚†Ñ‚†à‚†ô‚†ø‚£ø‚£ø‚£ø‚£Æ‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚°ø‚¢†‚†ä‚¢Ä‚°á‚£ø‚£ø
                  ‚†í‚†§‚†Ñ‚£ø‚°á‚¢Ä‚°≤‚†Ñ‚†Ñ‚†à‚†ô‚†ª‚¢ø‚£ø‚£ø‚†ø‚†ø‚†ü‚†õ‚†ã‚†Å‚£∞‚†á‚†Ñ‚¢∏‚£ø‚£ø‚£ø



                            DISCLAIMER

If, when creating your plugin, you decided to use the ready-made code solutions
of our plugin, then do not forget to mention the @MeeowPlugins channel in the description
of your plugin as credits for help in developing your plugin. Thanks



"""

import datetime
import json
import math
import os
import random
import textwrap
import threading
import time
import requests
import re

from PIL import Image, ImageDraw, ImageFont, ImageFilter, ImageEnhance
from PIL.Image import Resampling

from enum import Enum
from typing import Optional, Any, Callable, List, Dict
from secrets import choice

from android_utils import log, run_on_ui_thread
from base_plugin import BasePlugin, HookResult, HookStrategy, AppEvent, MenuItemData, MenuItemType
from client_utils import get_last_fragment, get_user_config, get_send_messages_helper, send_message, \
    get_messages_controller, send_request, get_messages_storage, get_account_instance
from markdown_utils import parse_markdown
from ui.alert import AlertDialogBuilder
from ui.bulletin import BulletinHelper
from ui.settings import Selector, Input, Divider, Header, Switch, Text

from java.io import File # type: ignore
from java.util import ArrayList, Locale # type: ignore

from android.content import Intent # type: ignore
from android.net import Uri # type: ignore

from com.exteragram.messenger.plugins import PluginsController # type: ignore
from com.exteragram.messenger.plugins.ui import PluginSettingsActivity # type: ignore

from org.telegram.tgnet import TLRPC # type: ignore
from org.telegram.tgnet.tl import TL_account # type: ignore
from org.telegram.messenger import ApplicationLoader, R, AndroidUtilities, SendMessagesHelper, MessageObject, MediaController # type: ignore

__id__ = "reswag"
__name__ = "reSwaga"
__description__ = "–ü–ª–∞–≥–∏–Ω –¥–ª—è –æ—Ç–ø—Ä–∞–≤–∫–∏ –∫–∞—Ä—Ç–æ—á–∫–∏/–∞—É–¥–∏–æ —Ñ–∞–π–ª–∞ —Ç–µ–∫—É—â–µ–≥–æ —Ç—Ä–µ–∫–∞ –¥–ª—è –º—É–∑—ã–∫–∞–ª—å–Ω—ã—Ö —Å–µ—Ä–≤–∏—Å–æ–≤."
__icon__ = "remusic/5"
__version__ = "1.0.0"
__author__ = "@meeowPlugins"
__min_version__ = "11.12.1"

RESOURCE_DIR_NAME: str = "resources"
RESOURCES: List[str] = [
    "Onest-Regular.ttf",
    "Onest-Bold.ttf",
    "Onest.ttf",
    "NotoSansJP-Regular.ttf",
    "NotoSansJP-Bold.ttf",
    "Circular-Regular.ttf",
    "Circular-Bold.ttf"
]

DOWNLOAD_URL: str = "https://raw.githubusercontent.com/cherryymerryy/reSwaga/main/"
REMOTE_CONFIG_URL: str = DOWNLOAD_URL + "config.json"
REMOTE_CONFIG: Dict[str, Any] = {}

EMPTY_TRACK_COVER = DOWNLOAD_URL + 'resources/empty_cover.png'

PLATFORMS_COUNT: int = 6

DEFAULT_COBALT_API_URL: str = 'https://co.otomir23.me'
DEFAULT_API_URL: str = "https://your.api.url"
DEFAULT_STREAM_STRING: str = "üéµ | {title} ‚Äî {artists}"
DEFAULT_VALUE: str = "platform value"
DEFAULT_STREAM_TEXT: str = "ü§ô"
DEFAULT_INSTANT_SUBTEXT: str = "Powered by"
DEFAULT_INSTANT_MAIN_TEXT: str = __name__

FONTS: Dict[int, str] = {
    0: "Onest",
    1: "Circular",
    2: "NotoSansJP"
}
DEFAULT_COLOR: Dict[str, str] = {
    "background_color": "#000000",
    "title_text_color": "#FFFFFF",
    "subtext_color": "#A0A0A0"
}


def logcat(message: Any):
    log(f"[{__id__}] {message}")


def show_error(message: str, on_click: Optional[Callable] = None, button_text: str = ""):
    if on_click is None:
        BulletinHelper.show_error(f"[{__name__}] {message}")
    elif on_click is not None and button_text != "":
        BulletinHelper.show_with_button(f"[{__name__}] {message}", R.raw.error, button_text, lambda: on_click())
    else:
        BulletinHelper.show_error(f"[{__name__}] {message}")


def show_info(message: str, on_click: Optional[Callable] = None, button_text: str = ""):
    if on_click is None:
        BulletinHelper.show_info(f"[{__name__}] {message}")
    elif on_click is not None and button_text != "":
        BulletinHelper.show_with_button(f"[{__name__}] {message}", R.raw.info, button_text, lambda: on_click())
    else:
        BulletinHelper.show_error(f"[{__name__}] {message}")


def show_success(message: str, on_click: Optional[Callable] = None, button_text: str = ""):
    if on_click is None:
        BulletinHelper.show_success(f"[{__name__}] {message}")
    elif on_click is not None and button_text != "":
        BulletinHelper.show_with_button(f"[{__name__}] {message}", R.raw.success, button_text, lambda: on_click())
    else:
        BulletinHelper.show_success(f"[{__name__}] {message}")


def get_temp_dir() -> Optional[File]:
    try:
        base_dir = ApplicationLoader.getFilesDirFixed()
        if not base_dir:
            return None
        temp_dir = File(base_dir.getAbsolutePath(), f"plugins/{RESOURCE_DIR_NAME}")
        if not temp_dir.exists() and not temp_dir.mkdirs():
            return None
        return temp_dir
    except Exception as e:
        logcat(f"Error getting/creating temp directory: {e}")
        return None


def read_remote_config():
    global REMOTE_CONFIG, RESOURCES
    try:
        req = requests.get(REMOTE_CONFIG_URL)
        if req.status_code == 200:
            decoded_content = req.content.decode('utf-8-sig')
            REMOTE_CONFIG = json.loads(decoded_content)
            logcat("Remote config received.")
        else:
            logcat("Remote config not found.")
    except Exception as e:
        logcat(f"Failed to receive remote config: {e}")


def download_file(url: str, file_path: str):
    if url is None or url == "":
        logcat("No URL provided to download.")
        return

    if file_path is None or file_path == "":
        logcat("No file_path provided to download.")
        return

    name = url.split("/").pop()

    try:
        logcat(f"Downloading {name}...")

        response = requests.get(url, timeout=15)
        response.raise_for_status()
        content = response.content

        if content:
            with open(file_path, "wb") as f:
                f.write(content)
            logcat(f"Successfully downloaded {name}.")
        else:
            logcat(f"Downloaded empty file for {name}.")

    except requests.exceptions.HTTPError as e:
        show_error(f"Failed to download {name}. Server returned error: {e}")
        logcat(f"Failed to download {name}. Server returned error: {e}")
    except requests.exceptions.RequestException as e:
        show_error(f"Failed to download {name} due to a network error: {e}")
        logcat(f"Failed to download {name} due to a network error: {e}")
    except IOError as e:
        show_error(f"Failed to save {name}. Permission or disk error: {e}")
        logcat(f"Failed to save {name}. Permission or disk error: {e}")
    except Exception as e:
        show_error(f"An unexpected error occurred while downloading {name}: {e}")
        logcat(f"An unexpected error occurred while downloading {name}: {e}")


def open_plugin_settings():
    try:
        java_plugin = PluginsController.getInstance().plugins.get(__id__)
        if java_plugin:
            run_on_ui_thread(lambda: get_last_fragment().presentFragment(PluginSettingsActivity(java_plugin)))
    except Exception as e:
        logcat(f"Error opening plugin settings: {e}")


def open_link(url: str):
    fragment = get_last_fragment()
    ctx = fragment.getContext() if fragment else ApplicationLoader.applicationContext
    intent = Intent(Intent.ACTION_VIEW, Uri.parse(url))
    run_on_ui_thread(lambda: ctx.startActivity(intent))


class LocaleController:
    def __init__(self):
        super().__init__()
        self.language: str = Locale.getDefault().getLanguage()

    def get_controller(self):
        if self.language == "ru":
            return self.LanguageRussian()
        # elif self.language == "pt":
        #     return self.lang_ptbr()
        else:
            return self.LanguageEnglish()


    class LanguageRussian:
        language = "ru"

        Settings_Auth_Header = "–°–µ—Ä–≤–∏—Å –∏ –ê–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—è"
        Settings_Auth_Platform = "–°–µ—Ä–≤–∏—Å"
        Settings_Auth_Value_Text = "–ó–Ω–∞—á–µ–Ω–∏–µ"
        Settings_Auth_Value_NotSelected_Text = "‚Äî"
        Settings_Auth_Value_Spotify_Text = "–Æ–∑–µ—Ä–Ω–µ–π–º"
        Settings_Auth_Value_YandexMusic_Text = "–¢–æ–∫–µ–Ω"
        Settings_Auth_Value_SoundCloud_Text = "–¢–æ–∫–µ–Ω"

        Settings_YandexMusic_LoginGuide = "–ü–µ—Ä–µ–π–¥–∏—Ç–µ –∫ –∏–Ω—Å—Ç—Ä—É–∫—Ü–∏–∏ –ø–æ –ø–æ–ª—É—á–µ–Ω–∏—é —Ç–æ–∫–µ–Ω–∞, –≤–æ–π–¥–∏—Ç–µ –≤ –∞–∫–∫–∞—É–Ω—Ç –Ø–Ω–¥–µ–∫—Å–∞ –∏ –≤—Å—Ç–∞–≤—å—Ç–µ —Ç–æ–∫–µ–Ω –Ω–∏–∂–µ."
        Settings_VkMusic_LoginGuide = "–ü–µ—Ä–µ–π–¥–∏—Ç–µ –Ω–∞ —Å–∞–π—Ç –∏ –∏–∑—É—á–∏—Ç–µ –∫–∞–∫ –Ω—É–∂–Ω–æ –ø—Ä–∞–≤–∏–ª—å–Ω–æ –ø–æ–ª—É—á–∏—Ç—å —Ç–æ–∫–µ–Ω, –ø–æ—Å–ª–µ –∏–∑—É—á–µ–Ω–∏—è –≤—ã–±–µ—Ä–∏—Ç–µ 'vk.com'"

        Settings_CobaltApi_Text = 'Cobalt API'
        Settings_CobaltApi_Subtext = '–ü—Ä–æ—Å–∏–º –Ω–µ –º–µ–Ω—è—Ç—å —ç—Ç–æ –∑–Ω–∞—á–µ–Ω–∏–µ –µ—Å–ª–∏ –Ω–µ –∑–Ω–∞–µ—Ç–µ –∑–∞ —á—Ç–æ –æ–Ω–æ –æ—Ç–≤–µ—á–∞–µ—Ç –∏ –∑–∞—á–µ–º –æ–Ω–æ –Ω—É–∂–Ω–æ.'

        Settings_CardSettings_Header = "–í–Ω–µ—à–Ω–∏–π –≤–∏–¥"

        Settings_BackgroundMode_Text = "–§–æ–Ω"
        Settings_BackgroundMode_Item_1 = "–û–±–ª–æ–∂–∫–∞ —Ç—Ä–µ–∫–∞"
        Settings_BackgroundMode_Item_2 = "–¶–≤–µ—Ç –æ–±–ª–æ–∂–∫–∏"

        Settings_Font_Text = "–®—Ä–∏—Ñ—Ç"
        Settings_Font_Item1 = "Onest"
        Settings_Font_Item2 = "Spotify"
        Settings_Font_Item3 = "NotoSansJP"

        Settings_PlatformLink_Text = "–í—Å—Ç–∞–≤—å—Ç–µ —Å—Å—ã–ª–∫—É –Ω–∞ ..."
        Settings_PlatformLink_Item_1 = "‚Äî"
        Settings_PlatformLink_Item_2 = "–¢—Ä–µ–∫"
        Settings_PlatformLink_Item_3 = "–ê–ª—å–±–æ–º"

        Settings_SongLinkInclude_Text = "–°—Å—ã–ª–∫–∞ –Ω–∞ –¥—Ä—É–≥–∏–µ –ø–ª–∞—Ç—Ñ–æ—Ä–º—ã"
        Settings_SongLinkInclude_Subtext = "–î–æ–±–∞–≤–ª—è–µ—Ç —Å—Å—ã–ª–∫—É –Ω–∞ —Å—Ç—Ä–∞–Ω–∏—Ü—É –ø–µ—Å–Ω–∏ –Ω–∞ song.link"
        Settings_FastCardRender_Text = "–ü—Ä–µ–¥–∑–∞–≥—Ä—É–∑–∫–∞ –∫–∞—Ä—Ç–æ—á–µ–∫"
        Settings_FastCardRender_Subtext = "–ú–æ–∂–µ—Ç —É–≤–µ–ª–∏—á–∏—Ç—å —Ä–∞—Å—Ö–æ–¥ –±–∞—Ç–∞—Ä–µ–∏"

        Setting_AdvancedMode_Text = "–†–∞—Å—à–∏—Ä–µ–Ω–Ω—ã–µ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏"
        Setting_AdvancedMode_Subtext = "–î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã –∫–∞—Å—Ç–æ–º–∏–∑–∞—Ü–∏–∏"
        Setting_AdvancedMode_Title = "–ù–∞—Å—Ç—Ä–æ–π–∫–∞ –≤–Ω–µ—à–Ω–µ–≥–æ –≤–∏–¥–∞"

        Settings_BackgroundColor_Text = "–¶–≤–µ—Ç —Ñ–æ–Ω–∞"
        Settings_BackgroundColor_Subtext = "–¶–≤–µ—Ç —Ñ–æ–Ω–∞ –ø—Ä–∏ –≤—ã–±–æ—Ä–µ '–¶–≤–µ—Ç –æ–±–ª–æ–∂–∫–∏' –≤ –ø–∞—Ä–∞–º–µ—Ç—Ä–µ '–§–æ–Ω'"

        Settings_AccentColor_Text = "–ê–∫—Ü–µ–Ω—Ç–Ω—ã–π —Ü–≤–µ—Ç"
        Settings_AccentColor_Subtext = "–¶–≤–µ—Ç —Ç–µ–∫—Å—Ç–∞ –≤ –Ω–∞–∑–≤–∞–Ω–∏–∏ —Ç—Ä–µ–∫–∞ –∏ –∞–∫—Ç–∏–≤–Ω–æ–º –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä–µ –ø—Ä–æ–≥—Ä–µ—Å—Å–∞"

        Settings_SecondaryColor_Text = "–í—Ç–æ—Ä–∏—á–Ω—ã–π —Ü–≤–µ—Ç"
        Settings_SecondaryColor_Subtext = "–¶–≤–µ—Ç —Ç–µ–∫—Å—Ç–∞ –¥–ª—è —Å—Ç—Ä–æ–∫–∏ —Å –∞—Ä—Ç–∏—Å—Ç–æ–º, –Ω–µ–∞–∫—Ç–∏–≤–Ω–æ–≥–æ –ø—Ä–æ–≥—Ä–µ—Å—Å-–±–∞—Ä–∞ –∏ —Ç–∞–π–º–µ—Ä–æ–≤"

        Settings_InstantCardSubtext_Text = "–í—Ç–æ—Ä–∏—á–Ω—ã–π —Ç–µ–∫—Å—Ç"
        Settings_InstantCardSubtext_Subtext = "–¢–µ–∫—Å—Ç –≤ –≤–µ—Ä—Ö–Ω–µ–π —á–∞—Å—Ç–∏ –Ω–∏–∂–Ω–µ–≥–æ –±–ª–æ–∫–∞ –ø—Ä–µ–¥–∑–∞–≥—Ä—É–∂–µ–Ω–Ω—ã—Ö –∫–∞—Ä—Ç–æ—á–µ–∫"

        Settings_InstantCardMainText_Text = "–û—Å–Ω–æ–≤–Ω–æ–π —Ç–µ–∫—Å—Ç"
        Settings_InstantCardMainText_Subtext = "–¢–µ–∫—Å—Ç –≤ –Ω–∏–∂–Ω–µ–π —á–∞—Å—Ç–∏ –Ω–∏–∂–Ω–µ–≥–æ –±–ª–æ–∫–∞ –ø—Ä–µ–¥–∑–∞–≥—Ä—É–∂–µ–Ω–Ω—ã—Ö –∫–∞—Ä—Ç–æ—á–µ–∫"

        Settings_Stream_Header = "–ü–æ—Ç–æ–∫ –≤ –ø—Ä–æ—Ñ–∏–ª—å"

        Setting_Stream_Title = "–ù–∞—Å—Ç—Ä–æ–π–∫–∏ —Å—Ç—Ä–∏–º–∞"
        Settings_Stream_Text = "–°—Ç—Ä–∏–º —Ç—Ä–µ–∫–∞ –≤ –ø—Ä–æ—Ñ–∏–ª—å"
        Settings_Stream_Subtext = "–û–±–Ω–æ–≤–ª—è–µ—Ç –±–∏–æ/–ª–æ–∫–∞—Ü–∏—é —Ç–µ–∫—É—â–∏–º —Ç—Ä–µ–∫–æ–º"
        Settings_Stream_Alert = "–†–µ–∫–æ–º–µ–Ω–¥—É–µ–º –≤–∞–º —Å–Ω–∞—á–∞–ª–∞ –Ω–∞—Å—Ç—Ä–æ–∏—Ç—å —Ç—Ä–∞–Ω—Å–ª—è—Ü–∏—é —Ç—Ä–µ–∫–∞, –∞ —É–∂–µ –ø–æ—Å–ª–µ —ç—Ç–æ–≥–æ –∞–∫—Ç–∏–≤–∏—Ä–æ–≤–∞—Ç—å —Ñ—É–Ω–∫—Ü–∏—é."

        Settings_StreamAlert_Title = "‚ö†Ô∏è‚ö†Ô∏è–í–ù–ò–ú–ê–ù–ò–ï‚ö†Ô∏è‚ö†Ô∏è"
        Settings_StreamAlert_Text = "–≠—Ç–∞ —Ñ—É–Ω–∫—Ü–∏—è –º–æ–∂–µ—Ç —Ä–∞–±–æ—Ç–∞—Ç—å –Ω–µ—Å—Ç–∞–±–∏–ª—å–Ω–æ –∏–∑-–∑–∞ –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–π Telegram –Ω–∞ —á–∞—Å—Ç—É—é —Å–º–µ–Ω—É –ø—Ä–æ—Ñ–∏–ª—è. –í–∞—à–∏ –¥–∞–Ω–Ω—ã–µ –º–æ–≥—É—Ç –æ–±–Ω–æ–≤–ª—è—Ç—å—Å—è —Å –∑–∞–¥–µ—Ä–∂–∫–æ–π. –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –Ω–∞ —Å–≤–æ–π —Å—Ç—Ä–∞—Ö –∏ —Ä–∏—Å–∫."

        Setting_TrackStream_Text = "–°—Ç—Ä–∏–º–∏—Ç—å –≤..."
        Setting_TrackStream_Item1 = "–ë–∏–æ"
        Setting_TrackStream_Item2 = "–õ–æ–∫–∞—Ü–∏—é (—Ä–µ–∫–æ–º–µ–Ω–¥—É–µ—Ç—Å—è)"

        Settings_InStream_Text = "–¢–µ–∫—Å—Ç –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é"
        Settings_InStream_Subtext = "–û—Ç–æ–±—Ä–∞–∂–∞–µ—Ç—Å—è, –µ—Å–ª–∏ –ø–ª–µ–µ—Ä –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω –∏–ª–∏ –Ω–∏—á–µ–≥–æ –Ω–µ –≤–æ—Å–ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç—Å—è"

        Settings_FormatInStream_Text = "–§–æ—Ä–º–∞—Ç"
        Settings_FormatInStream_Subtext = "–§–æ—Ä–º–∞—Ç –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è —Ç—Ä–µ–∫–∞. {title} ‚Äî –Ω–∞–∑–≤–∞–Ω–∏–µ —Ç—Ä–µ–∫–∞, {artists} ‚Äî –∞—Ä—Ç–∏—Å—Ç(—ã)"

        Settings_Cache_Header = "–ö—ç—à"
        Setting_Cache_Enable_Text = "–ö—ç—à–∏—Ä–æ–≤–∞–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏"
        Setting_Cache_DeleteCached = "–û—á–∏—Å—Ç–∏—Ç—å –∫—ç—à–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏"

        Settings_Other_Header = "–ü—Ä–æ—á–µ–µ"

        Setting_Other_SourceCheck = "–ü—Ä–æ–≤–µ—Ä–∫–∞ —Ü–µ–ª–æ—Å—Ç–Ω–æ—Å—Ç–∏ —Ñ–∞–π–ª–æ–≤"
        Setting_Other_ForceDownload = "–°–∫–∞—á–∞—Ç—å –≤—Å–µ —Ä–µ—Å—É—Ä—Å—ã –∑–∞–Ω–æ–≤–æ"
        Setting_Other_Donate = "–ü–æ–¥–¥–µ—Ä–∂–∞—Ç—å —Ä–∞–∑—Ä–∞–±–æ—Ç–∫—É"

        Settings_YandexMusic_Auth_Guide = "–ò–Ω—Å—Ç—Ä—É–∫—Ü–∏—è –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏"
        Settings_YandexMusic_Auth_Guide_Text = "**–∏–Ω—Å—Ç—Ä—É–∫—Ü–∏—è**"

        Settings_YandexMusic_CustomApi_Enable_Text = "–í–∫–ª—é—á–∏—Ç—å –∫–∞—Å—Ç–æ–º–Ω–æ–µ API"
        Settings_YandexMusic_CustomApi_Enable_Subtext = "–í–Ω–∏–º–∞–Ω–∏–µ! –í–∫–ª—é—á–∞–π—Ç–µ —ç—Ç–æ —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ –≤—ã –∑–Ω–∞–µ—Ç–µ —á—Ç–æ –¥–µ–ª–∞–µ—Ç–µ."

        Settings_YandexMusic_CustomApi_Input_Text = "–ö–∞—Å—Ç–æ–º–Ω–æ–µ API"
    
        Alert_HEX_Title = "‚ö†Ô∏è –û—à–∏–±–∫–∞ HEX"
        Alert_HEX_Text = "–ù–µ–¥–æ–ø—É—Å—Ç–∏–º—ã–π HEX-–∫–æ–¥ —Ü–≤–µ—Ç–∞"
        
        Message_CaptionLink_Text = "[{0}]({1})"
        Message_CaptionSongLink_Text = "[song.link]({0})"
        Message_CaptionDivider = " ‚Ä¢ "

        Check_Value_NotValid = "–£–∫–∞–∑–∞–Ω–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ —Å–µ—Ä–≤–∏—Å–∞ –Ω–µ –≤–∞–ª–∏–¥–Ω–æ."
        Check_Value_NotValid_Button = "–ò–∑–º–µ–Ω–∏—Ç—å"

        Check_Platform_NotSelected = "–í—ã –Ω–µ —É–∫–∞–∑–∞–ª–∏ –∏—Å–ø–æ–ª—å–∑—É–µ–º—ã–π –≤–∞–º–∏ —Å–µ—Ä–≤–∏—Å."
        Check_Platform_NotSelected_Button = "–í—ã–±—Ä–∞—Ç—å"

        Check_Platform_DownloadNotAvailable = "–î–ª—è —Ç–µ–∫—É—â–µ–≥–æ —Å–µ—Ä–≤–∏—Å–∞ '.nowt' –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–∞."
        
        Check_Resources_NotFound = "–ù–µ–æ–±—Ö–æ–¥–∏–º—ã–µ —Ä–µ—Å—É—Ä—Å—ã –Ω–µ –Ω–∞–π–¥–µ–Ω—ã."
        Check_Resources_NotFound_Button = "–°–∫–∞—á–∞—Ç—å"

        CachedAuthData_Clear_Success = "–ö—ç—à–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏ —É–¥–∞–ª–µ–Ω—ã."
        CachedAuthData_Clear_Error = "–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –≤–æ –≤—Ä–µ–º—è —É–¥–∞–ª–µ–Ω–∏—è –∫—ç—à–∏—Ä–æ–≤–∞–Ω–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö."

        SourceSuccess_Title = "–£—Å–ø–µ—à–Ω–æ"
        SourceSuccess_Text = "–û—à–∏–±–æ–∫ –ø—Ä–∏ –ø—Ä–æ–≤–µ—Ä–∫–µ —Ä–µ—Å—É—Ä—Å–æ–≤ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ"

        Track_Not_Active = "–ü–ª–µ–µ—Ä –Ω–µ–∞–∫—Ç–∏–≤–µ–Ω."

        VkMusic_Id = "ID –∞–∫–∫–∞—É–Ω—Ç–∞ VK"
        VkMusic_Id_NotValid = "ID –∞–∫–∫–∞—É–Ω—Ç–∞ VK –Ω–µ –≤–∞–ª–∏–¥–µ–Ω."
        VkMusic_Audio_NotFound = "–¢—Ä–µ–∫ –Ω–µ –Ω–∞–π–¥–µ–Ω."
        VkMusic_Warning = "‚ùó‚ùó‚ùó–í–Ω–∏–º–∞–Ω–∏–µ‚ùó‚ùó‚ùó\n–°–µ—Ä–≤–∏—Å –í–ö –ú—É–∑—ã–∫–∞ –±—É–¥–µ—Ç —Ä–∞–±–æ—Ç–∞—Ç—å —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ —É –≤–∞—Å –í–ö –≤–∫–ª—é—á–µ–Ω–∞ —Ç—Ä–∞–Ω—Å–ª—è—Ü–∏—è —Ç—Ä–µ–∫–∞ –≤ –≤–∞—à –ø—Ä–æ—Ñ–∏–ª—å."

        Action_Fix = "–ò—Å–ø—Ä–∞–≤–∏—Ç—å"

        Platform_YandexMusic = "–Ø–Ω–¥–µ–∫—Å –ú—É–∑—ã–∫–∞"
        Platform_VkMusic = "–í–ö –ú—É–∑—ã–∫–∞"

        Alert_Donate_Title = "–ü–æ–¥–¥–µ—Ä–∂–∫–∞ —Ä–∞–∑—Ä–∞–±–æ—Ç–∫–∏"
        Alert_Donate_Text = "–ù–∏–∂–µ –≤—ã –º–æ–∂–µ—Ç–µ —Å–∫–æ–ø–∏—Ä–æ–≤–∞—Ç—å TON-–∞–¥—Ä–µ—Å —Ä–∞–∑—Ä–∞–±–æ—Ç—á–∏–∫–æ–≤ reSwaga –∏ –ø–æ–¥–¥–µ—Ä–∂–∞—Ç—å –ø—Ä–æ–µ–∫—Ç –¥–æ–Ω–∞—Ç–æ–º."
        Alert_Donate_Button = "–°–∫–æ–ø–∏—Ä–æ–≤–∞—Ç—å"

        Bulletin_InvalidCobaltResponse = "–ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π –æ—Ç–≤–µ—Ç –æ—Ç Cobalt API"
        Bulletin_NoItemsToDownload = "–ù–µ—Ç —ç–ª–µ–º–µ–Ω—Ç–æ–≤ –¥–ª—è –∑–∞–≥—Ä—É–∑–∫–∏"
        Bulletin_CobaltErrorCode = "[reSwaga]: –û—à–∏–±–∫–∞ Cobalt, –∫–æ–¥ ‚Äî {0}"

        MenuItem_Service_Select_Text = "–í—ã–±—Ä–∞—Ç—å {0}"
        MenuItem_Service_Select_Subtext = "–°–µ—Ä–≤–∏—Å –≤ reSwaga"
        MenuItem_Service_Success = "–°–µ—Ä–≤–∏—Å –æ–±–Ω–æ–≤–ª–µ–Ω –Ω–∞ {0}."
        MenuItem_Service_Fail = "–ù–µ —É–¥–∞–ª–æ—Å—å –æ–±–Ω–æ–≤–∏—Ç—å —Å–µ—Ä–≤–∏—Å –Ω–∞ {0}."

    class LanguageEnglish:
        language = "en"

        Settings_Auth_Header = "Service & Authorization"
        Settings_Auth_Platform = "Service"
        Settings_Auth_Value_Text = "Value"
        Settings_Auth_Value_NotSelected_Text = "‚Äî"
        Settings_Auth_Value_Spotify_Text = "Username"
        Settings_Auth_Value_YandexMusic_Text = "Token"
        Settings_Auth_Value_SoundCloud_Text = "Token"

        Settings_YandexMusic_LoginGuide = "Go to token guide, log in to your Yandex account, and paste your token below."
        Settings_VkMusic_LoginGuide = "Go to the website and learn how to get a token correctly. After studying, select 'vk.com' and log-in in to your VK account."

        Settings_CobaltApi_Text = 'Cobalt API Url'
        Settings_CobaltApi_Subtext = 'Please do not change this value if you do not know what it is responsible for and why it is needed.'

        Settings_CardSettings_Header = "Customization"

        Settings_BackgroundMode_Text = "Background"
        Settings_BackgroundMode_Item_1 = "Track Cover"
        Settings_BackgroundMode_Item_2 = "Cover Color"

        Settings_Font_Text = "Font"
        Settings_Font_Item1 = "Onest"
        Settings_Font_Item2 = "Spotify"
        Settings_Font_Item3 = "NotoSansJP"

        Settings_PlatformLink_Text = "Insert link to ..."
        Settings_PlatformLink_Item_1 = "‚Äî"
        Settings_PlatformLink_Item_2 = "Track"
        Settings_PlatformLink_Item_3 = "Album"

        Settings_SongLinkInclude_Text = "Link to other platforms"
        Settings_SongLinkInclude_Subtext = "Adds a link to the song page on song.link"
        Settings_FastCardRender_Text = "Pre-render cards"
        Settings_FastCardRender_Subtext = "May increase battery consumption"

        Setting_AdvancedMode_Text = "Advanced Settings"
        Setting_AdvancedMode_Subtext = "Additional customization settings"
        Setting_AdvancedMode_Title = "Customization"

        Settings_BackgroundColor_Text = "Background Color"
        Settings_BackgroundColor_Subtext = "Background color if 'Cover Color' is selected in 'Background'"

        Settings_AccentColor_Text = "Accent Color"
        Settings_AccentColor_Subtext = "Text color used in track title and active progress bar"

        Settings_SecondaryColor_Text = "Secondary Color"
        Settings_SecondaryColor_Subtext = "Text color used for artist line, inactive progress bar, and timers"

        Settings_InstantCardSubtext_Text = "Secondary Text"
        Settings_InstantCardSubtext_Subtext = "Text displayed at the top of the bottom block of pre-rendered cards"

        Settings_InstantCardMainText_Text = "Main Text"
        Settings_InstantCardMainText_Subtext = "Text displayed at the bottom of the bottom block of pre-rendered cards"

        Settings_Stream_Header = "Profile Streaming"

        Setting_Stream_Title = "Stream settings"
        Settings_Stream_Text = "Stream track to profile"
        Settings_Stream_Subtext = "Updates your bio/location with the currently playing track"
        Settings_Stream_Alert = "We recommend that you first set up the broadcast of the track, and only after that activate the function."

        Settings_StreamAlert_Title = "‚ö†Ô∏è‚ö†Ô∏èWARNING‚ö†Ô∏è‚ö†Ô∏è"
        Settings_StreamAlert_Text = "This feature may work inconsistently due to Telegram's profile change limits. As a result, your profile information may not update immediately. Use at your own risk."

        Setting_TrackStream_Text = "Stream to..."
        Setting_TrackStream_Item1 = "Bio"
        Setting_TrackStream_Item2 = "Location (Recommended)"

        Settings_InStream_Text = "Default Text"
        Settings_InStream_Subtext = "Text displayed when the player is unavailable or no track is playing"

        Settings_FormatInStream_Text = "Format"
        Settings_FormatInStream_Subtext = "Customize track display. {title} ‚Äî track name, {artists} ‚Äî artist(s)"

        Settings_Cache_Header = "Cache"
        Setting_Cache_Enable_Text = "Caching of authorization data"
        Setting_Cache_DeleteCached = "Delete cached authentication data"

        Settings_Other_Header = "Other"

        Setting_Other_SourceCheck = "File Integrity Check"
        Setting_Other_ForceDownload = "Download Full Resource Package"
        Setting_Other_Donate = "Support Development"

        Settings_YandexMusic_Auth_Guide = "Authentication Guide"
        Settings_YandexMusic_Auth_Guide_Text = "**guide**"

        Settings_YandexMusic_CustomApi_Enable_Text = "Enable Custom API"
        Settings_YandexMusic_CustomApi_Enable_Subtext = "Warning! Enable this only if you know what you doing."

        Settings_YandexMusic_CustomApi_Input_Text = "Custom API Url"

        Alert_HEX_Title = "‚ö†Ô∏è HEX Error"
        Alert_HEX_Text = "Invalid HEX color code"
        
        Message_CaptionLink_Text = "[{0}]({1})"
        Message_CaptionSongLink_Text = "[song.link]({0})"
        Message_CaptionDivider = " ‚Ä¢ "

        Check_Value_NotValid = "Platform value is not valid."
        Check_Value_NotValid_Button = "Change"

        Check_Platform_NotSelected = "You can't use command without selected platform."
        Check_Platform_NotSelected_Button = "Select"

        Check_Platform_DownloadNotAvailable = "For current service '.nowt' not available."

        Check_Resources_NotFound = "Plugin resources not found."
        Check_Resources_NotFound_Button = "Download"

        CachedAuthData_Clear_Success = "Cached authorization data removed."
        CachedAuthData_Clear_Error = "Something went wrong, cached data not removed."

        SourceSuccess_Title = "Success"
        SourceSuccess_Text = "No issues detected during resource check"

        Track_Not_Active = "Player not active."

        VkMusic_Id = "VK account ID"
        VkMusic_Id_NotValid = "VK account ID not valid."
        VkMusic_Audio_NotFound = "Track not found."
        VkMusic_Warning = "‚ùó‚ùó‚ùóWarning‚ùó‚ùó‚ùó\nService VK Music working only if you enabled stream track in to profile in VK"

        Action_Fix = "Fix"

        Platform_YandexMusic = "Yandex.Music"
        Platform_VkMusic = "VK Music"

        Alert_Donate_Title = "Support Development"
        Alert_Donate_Text = "Below you can copy the TON address of the reSwaga developers and support the development with your donation."
        Alert_Donate_Button = "Copy"

        Bulletin_InvalidCobaltResponse = "Invalid response from Cobalt API"
        Bulletin_NoItemsToDownload = "No items to download"
        Bulletin_CobaltErrorCode = "[reSwaga]: Cobalt Error Code ‚Äî {0}"

        MenuItem_Service_Select_Text = "Select {0}"
        MenuItem_Service_Select_Subtext = "Service in reSwaga"
        MenuItem_Service_Success = "Selected {0} as main service."
        MenuItem_Service_Fail = "Failed to select {0} as main service."


locale = LocaleController().get_controller()


class Track:
    def __init__(
            self,
            active: bool,
            track_id: int = None,
            title: str = None,
            artist: list = None,
            album: str = None,
            thumb: str = None,
            duration: int = None,
            progress: int = None,
            link: str = None,
            device: str = None,
            download_url: str = None,
    ):
        self.active = active
        self.track_id = track_id
        self.title = title
        self.artist = artist
        self.album = album
        self.thumb = thumb
        self.duration = duration
        self.progress = progress
        self.link = link
        self.device = device
        self.download_url = download_url


class Platform(Enum):
    NotSelected = (0, locale.Settings_Auth_Value_NotSelected_Text)
    Spotify = (1, 'Spotify')
    YandexMusic = (2, locale.Platform_YandexMusic)
    SoundCloud = (3, 'SoundCloud')
    VkMusic = (4, locale.Platform_VkMusic)
    TgMusic = (5, 'Telegram')


class BasePlatform:
    def __init__(self, value: str):
        self.now_track: Optional[Track] = None

        if value not in ['', None, DEFAULT_VALUE]:
            self.value: str = value
        else:
            logcat("Value is none.")

        self.memory_id: int = 0
        self.value_text: Optional[str] = None
        self.pre_auth_settings: Optional[bool] = None
        self.additional_settings: Optional[bool] = None
        self.can_download_track: bool = True
        self.need_special_platform_args_check: bool = False

    def get_track(self) -> Optional[Track]:
        pass

    def special_platform_args_check(self, plugin: BasePlugin) -> bool:
        pass

    def create_pre_auth_settings(self, plugin: BasePlugin) -> List[Any]:
        pass

    def create_additional_settings(self, plugin: BasePlugin) -> List[Any]:
        pass


class Spotify(BasePlatform):
    def __init__(self, value: str):
        super().__init__(value)
        self.value_text = locale.Settings_Auth_Value_Spotify_Text
        username = value.strip() if value else ""
        if '/' in username:
            username = username.split('/')[-1]
        self.username = username
        self.headers = {"User-Agent": "Mozilla/5.0", "Accept": "application/json"}
        self.now_track = Track(active=False)

    def get_track(self) -> Optional[Track]:
        data = requests.get(f"https://api.stats.fm/api/v1/users/{self.username}/streams/current", headers=self.headers)

        if data.status_code == 204 or data.status_code != 200:
            self.now_track = Track(active=False)
            return Track(active=False)
        else:
            data = data.json()['item']
            if data:
                track_id = data['track']['externalIds']['spotify']
                track_id = track_id[0] if track_id else 0
                album = self.get_album_link(data['track']['id'])
                track = Track(
                    active=True,
                    track_id=track_id,
                    title=data['track']['name'],
                    artist=[artist['name'] for artist in data['track']['artists']],
                    album=album,
                    thumb=data['track']['albums'][0]['image'],
                    duration=data['track']['durationMs'] // 1000,
                    progress=data['progressMs'] // 1000,
                    link=f"https://open.spotify.com/track/{track_id}",
                    device=data['deviceName']
                )
            else:
                self.now_track = Track(active=False)
                track = Track(active=False)

            self.now_track = track
            return track

    def get_album_link(self, internal_track_id) -> Optional[str]:
        data = requests.get(f"https://api.stats.fm/api/v1/tracks/{internal_track_id}/albums", headers=self.headers)
        if data.status_code != 200:
            return None
        else:
            data = data.json()['items']
            if data:
                try:
                    if data[0]['externalIds']['spotify'][0]:
                        album_id = data[0]['externalIds']['spotify'][0]
                        return f"https://open.spotify.com/album/{album_id}"

                    elif data[0]['externalIds']['appleMusic'][0]:
                        album_id = data[0]['externalIds']['appleMusic'][0]
                        return f"https://open.spotify.com/album/{album_id}"

                    else:
                        album_id = data[0]['externalIds']['id']
                        return f"https://open.spotify.com/album/{album_id}"
                except Exception as e:
                    logcat("[Spotify] get_album_link: " + str(e))
                    return None
            else:
                return None


class YandexMusic(BasePlatform):
    def __init__(self, value: str, api_url: Optional[str] = None):
        super().__init__(value)
        self.token = value.strip()
        self.value_text = locale.Settings_Auth_Value_YandexMusic_Text
        self.pre_auth_settings = True
        self.additional_settings = True
        self.need_special_platform_args_check = True
        self.api_url: str = api_url if api_url else "https://track.mipoh.ru"
        self.headers = {
            "User-Agent": "Mozilla/5.0", 
            "Accept": "application/json", 
            "ya-token": self.token
        }

    def get_track(self) -> Optional[Track]:
        if not self.token:
            self.now_track = Track(active=False)
            return Track(active=False)

        try:
            r = requests.get(f"{self.api_url}/get_current_track_beta", headers=self.headers, timeout=10, verify=False)
            logcat(f"[YandexMusic] get_current_track status={r.status_code}")
            data = r.json()

            if r.status_code != 200 or 'track' not in data:
                logcat("[YandexMusic] no 'track' key or bad status")
                self.now_track = Track(active=False)
                return Track(active=False)

            t = data['track']

            raw_artist = t.get('artist', '')
            if isinstance(raw_artist, str):
                artists = [x.strip() for x in raw_artist.split(',') if x.strip()]
            elif isinstance(raw_artist, list):
                artists = raw_artist
            else:
                artists = []

            track = Track(
                active=True,
                track_id=t.get('track_id'),
                title=t.get('title'),
                artist=artists,
                album=t.get('album'),
                thumb=t.get('img'),
                duration=int(t.get('duration', 0)),
                progress=int(data.get('progress_ms', 0)) // 1000,
                link=f"https://music.yandex.ru/track/{t.get('track_id')}",
                download_url=t.get('download_link')
            )
            self.now_track = track
            logcat(f"[YandexMusic] built track: {track.title} ‚Äî {track.artist}")
            return track
        except Exception as e:
            logcat(f"[YandexMusic] get_current_track exception: {e}")
            self.now_track = Track(active=False)
            return Track(active=False)

    def special_platform_args_check(self, plugin):
        if plugin.get_setting('enable_yandex_custom_api_url', False):
            yandex_custom_api: Optional[str] = plugin.get_setting('yandex_custom_api', None)
            if yandex_custom_api in ["", None]:
                return True
            elif not yandex_custom_api.startswith('https://') and not yandex_custom_api.startswith('http://'):
                return True
            elif len(yandex_custom_api) <= 7:
                return True
            else:
                return True
        else:
            return False

    def create_pre_auth_settings(self, plugin):
        return [
            Text(
                text=locale.Settings_YandexMusic_Auth_Guide,
                icon="msg_info",
                on_click=lambda _: plugin.show_info_alert(
                    title=locale.Settings_YandexMusic_Auth_Guide,
                    message=locale.Settings_YandexMusic_LoginGuide,
                    positive_text="Ok",
                    neutral_text="Guide",
                    neutral_listener=lambda: open_link("https://yandex-music.readthedocs.io/en/main/token.html")
                )
            )
        ]

    def create_additional_settings(self, plugin: BasePlugin):
        custom_api_url = plugin.get_setting("enable_yandex_custom_api_url", False)
        return [
            Switch(
                key="enable_yandex_custom_api_url",
                text=locale.Settings_YandexMusic_CustomApi_Enable_Text,
                subtext=locale.Settings_YandexMusic_CustomApi_Enable_Subtext,
                icon="msg_language",
                default=False,
                on_change=lambda _: plugin.update_platform_object(
                    plugin.get_setting("selected_platform", int(Platform.NotSelected.value[0])),
                    True
                )
            ),
            Input(
                key="yandex_custom_api",
                text=locale.Settings_YandexMusic_CustomApi_Input_Text,
                icon="msg_instant_link",
                default=DEFAULT_API_URL,
                on_change=lambda _: plugin.update_platform_object(
                    plugin.get_setting("selected_platform", int(Platform.NotSelected.value[0])),
                    True
                )
            ) if custom_api_url else None,
            Text(
                text="Custom API Guide",
                icon="msg_info",
                on_click=lambda _: plugin.show_info_alert(
                    title="custom api guide",
                    message="guide",
                    positive_text="Ok",
                    neutral_text="Guide",
                    neutral_listener=lambda: open_link("https://github.com/MIPOHBOPOHIH/YMMBFA")
                )
            ) if custom_api_url else None
        ]


class SoundCloud(BasePlatform):
    def __init__(self, value: str):
        super().__init__(value)
        self.value_text = locale.Settings_Auth_Value_SoundCloud_Text

        if not value: return
        self.token: str = value.strip()

        chrome_user_agents = [
            'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/535.1 (KHTML, like Gecko) Chrome/13.0.782.112 Safari/535.1',
            'Mozilla/5.0 (Windows NT 6.0) AppleWebKit/535.1 (KHTML, like Gecko) Chrome/13.0.782.112 Safari/535.1',
            'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.31 (KHTML, like Gecko) Chrome/26.0.1410.64 Safari/537.31',
            'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/27.0.1453.116 Safari/537.36',
            'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/27.0.1453.110 Safari/537.36',
            'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/31.0.1650.63 Safari/537.36',
            'Mozilla/5.0 (Windows NT 6.1) AppleWebKit/537.31 (KHTML, like Gecko) Chrome/26.0.1410.64 Safari/537.31',
            'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/30.0.1599.101 Safari/537.36',
            'Mozilla/5.0 (Windows NT 5.1) AppleWebKit/537.31 (KHTML, like Gecko) Chrome/26.0.1410.64 Safari/537.31',
            'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.1 (KHTML, like Gecko) Chrome/21.0.1180.89 Safari/537.1',
            'Mozilla/5.0 (Windows NT 6.1) AppleWebKit/537.1 (KHTML, like Gecko) Chrome/21.0.1180.89 Safari/537.1',
            'Mozilla/5.0 (Windows NT 6.1) AppleWebKit/535.1 (KHTML, like Gecko) Chrome/14.0.835.163 Safari/535.1',
            'Mozilla/5.0 (Windows; U; Windows NT 6.1; en-US) AppleWebKit/532.0 (KHTML, like Gecko) Chrome/3.0.195.27 Safari/532.0',
            'Mozilla/5.0 (Windows NT 6.1) AppleWebKit/535.1 (KHTML, like Gecko) Chrome/14.0.835.186 Safari/535.1',
            'Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US) AppleWebKit/532.0 (KHTML, like Gecko) Chrome/3.0.195.38 Safari/532.0',
            'Mozilla/5.0 (Windows; U; Windows NT 6.1; en-US) AppleWebKit/532.2 (KHTML, like Gecko) Chrome/4.0.221.7 Safari/532.2',
            'Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US) AppleWebKit/525.13 (KHTML, like Gecko) Chrome/0.2.149.29 Safari/525.13',
            'Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US) AppleWebKit/525.13 (KHTML, like Gecko) Chrome/0.2.149.27 Safari/525.13',
        ]

        self.headers: Dict[str, str] = {
            'User-Agent': choice(chrome_user_agents),
            'Authorization': f'OAuth {self.token}',
            'Origin': 'https://soundcloud.com',
            'Referer': 'https://soundcloud.com/',
        }
        self.params: Dict[str, str] = {
            'client_id': '1HxML01xkzWgtHfBreaeZfpANMe3ADjb',
            'app_version': '1739181955',
            'app_locale': 'en',
            'limit': '20',
            'offset': '0',
            'linked_partitioning': '1'
        }
        self.api_url: str = 'https://api-v2.soundcloud.com/'
        self.can_download_track = False

    def get_track(self) -> Optional[Track]:
        if not self.token:
            self.now_track = Track(active=False)
            return Track(active=False)

        try:
            data = requests.get(
                url=f"{self.api_url}me/play-history/tracks",
                params=self.params,
                headers=self.headers
            )

            if data.status_code != 200:
                logcat(f"[Soundcloud] Status code: {data.status_code}")
                self.now_track = Track(active=False)
                return Track(active=False)

            collection = data.json()['collection']

            if not collection or len(collection) <= 0:
                logcat("[Soundcloud] Collection is empty")
                self.now_track = Track(active=False)
                return Track(active=False)

            track_id: int = collection[0].get('track_id', 0)
            t: Dict[str, Any] = collection[0].get('track', None)

            if not t:
                logcat("[Soundcloud] TrackInfo is None")
                self.now_track = Track(active=False)
                return Track(active=False)

            metadata: Optional[Dict[str, Any]] = t.get('publisher_metadata', None)
            if not metadata:
                logcat("[Soundcloud] Metadata is None")
                self.now_track = Track(active=False)
                return Track(active=False)

            raw_artist: str = metadata.get('artist', '')
            if isinstance(raw_artist, str):
                artists = [x.strip() for x in raw_artist.split(',') if x.strip()]
            elif isinstance(raw_artist, list):
                artists = raw_artist
            else:
                artists = []

            track = Track(
                active=True,
                track_id=track_id,
                title=t.get('title', 'No title provided'),
                artist=artists,
                album=metadata.get('album_title', ''),
                thumb=t.get('artwork_url', ''),
                duration=int(t.get('duration', 0)) // 1000,
                link=t.get('permalink_url', '')
            )

            self.now_track = track
            logcat(f"[Soundcloud] built track: {track.title} ‚Äî {track.artist}")
            return track

        except Exception as e:
            logcat(f"[Soundcloud] Exception in get_track: {e}")
            self.now_track = Track(active=False)
            show_info(str(e))
            return Track(active=False)

# FROM 'VkNowPlay' PLUGIN
class VkMusic(BasePlatform):
    def __init__(self, value: str, vk_id: Optional[int] = None):
        super().__init__(value)
        self.value_text = locale.Settings_Auth_Value_YandexMusic_Text
        self.token: str = value.strip()
        self.vk_id: Optional[int] = vk_id
        self.pre_auth_settings = True
        self.additional_settings = True
        self.can_download_track = False
        self.need_special_platform_args_check = True

    def get_track(self) -> Optional[Track]:
        params: Dict[str, Any] = {
            'user_ids': self.vk_id,
            'fields': 'status',
            'v': 5.199,
            'access_token': self.token
        }

        try:
            response = requests.get('https://api.vk.com/method/users.get', params=params)
            data = response.json()

            if data.get('response', None) is None:
                logcat('Response not found')
                return Track(active=False)
            
            response = data['response'][0]

            if response.get('status_audio', None) is None:
                show_info(locale.VkMusic_Audio_NotFound)
                logcat('Audio status not found')
                return Track(active=False)
            
            t = response.get('status_audio', None)
            if t is None:
                logcat('Audio status not found2')
                return Track(active=False)
            
            main_artists: list = t.get('main_artists', None)
            if main_artists is None:
                artists_names: List[str] = [t.get('artist', 'Artist w/out name')]
            else:
                artists: list = [ma for ma in main_artists]
                artists_names: List[str] = [a.get('name', 'Artist w/out name') for a in artists]

            thumbnail = EMPTY_TRACK_COVER
            link: str = f"https://vk.com/audio{t.get('owner_id', 0)}_{t.get('id', 0)}"
            album = t.get('album', None)

            if not album is None:
                album_link: str = f"https://vk.com/music/album/{album.get('owner_id', 0)}_{album.get('id', 0)}_{album.get('access_key', None)}"
                thumb = album.get('thumb', None)
                if not thumb is None:
                    thumbnail = thumb.get('photo_1200', None)
            else:
                album_link: str = link

            track = Track(
                active=True,
                track_id=t.get('id', 0),
                title=t.get('title', 'No title provided'),
                artist=artists_names,
                album=album_link,
                thumb=thumbnail,
                link=link
            )

            self.now_track = track
            return track
        
        except Exception as e:
            import traceback
            logcat(f"Exception occurred while getting VK status: {e}\nFull traceback: {traceback.format_exc()}")
            return Track(active=False)

    def special_platform_args_check(self, plugin):
        if plugin.get_setting('vk_music_id', None) in [0, None, ""]:
            show_error(
                message=locale.VkMusic_Id_NotValid,
                on_click=lambda: open_plugin_settings(),
                button_text=locale.Action_Fix
            )
            return True
        
        else:
            return False

    def create_pre_auth_settings(self, plugin):
        return [
            Text(
                text=locale.Settings_YandexMusic_Auth_Guide,
                icon="msg_info",
                on_click=lambda _: plugin.show_info_alert(
                    title=locale.Settings_YandexMusic_Auth_Guide,
                    message=locale.Settings_VkMusic_LoginGuide,
                    positive_text="Ok",
                    neutral_text="Guide",
                    neutral_listener=lambda: open_link("https://vkhost.github.io/")
                )
            ),
            Input(
                key="vk_music_id",
                text=locale.VkMusic_Id,
                icon="msg_mention",
                default="0",
                on_change=lambda _: plugin.update_platform_object(
                    plugin.get_setting("selected_platform", int(Platform.NotSelected.value[0])),
                    True
                )
            )
        ]

    def create_additional_settings(self, plugin):
        return [
            Divider(
                text=locale.VkMusic_Warning
            )
        ]


class TgMusic(BasePlatform):
    def __init__(self, value):
        super().__init__(value)
        self.can_download_track = False

    def get_track(self):
        now_playing = MediaController.getInstance().getPlayingMessageObject()
        if now_playing is None or MediaController.getInstance().isMessagePaused() or not now_playing.isMusic():
            self.now_track = Track(active=False)
            return Track(active=False)
        
        owner_id = now_playing.messageOwner.id
        title = now_playing.getMusicTitle()
        author = now_playing.getMusicAuthor()

        # pizdec govnishe
        artwork = now_playing.getArtworkUrl(False)
        req = requests.get(str(artwork).replace('athumb', 'https')).json()
        results: Optional[List[Dict[str, str]]] = req.get('results', None)

        if results is None or len(results) <= 0 or results[0] is None:
            album = None
            link = None
            thumbnail = EMPTY_TRACK_COVER
        else:
            owner_id = results[0].get('trackId', now_playing.messageOwner.id)
            album = results[0].get('collectionViewUrl', None)
            link = results[0].get('trackViewUrl', None)
            artwork_url = results[0].get('artworkUrl30', None)
            thumbnail = str(artwork_url).replace('30x30bb', '600x600bb') if not artwork_url is None else EMPTY_TRACK_COVER

        duration = now_playing.getDuration()
        progress = now_playing.audioProgressSec

        track = Track(
            active=True,
            track_id=owner_id,
            title=title,
            artist=[author],
            album=album,
            thumb=thumbnail,
            duration=duration,
            progress=progress,
            link=link
        )
        self.now_track = track
        return track


def read(path: str) -> Optional[Any]:
    if not os.path.exists(path):
        return None
    try:
        with open(path, "rb") as file:
            file_content = file.read()
        return json.loads(file_content.decode("utf-8", errors="replace"))
    except Exception:
        import traceback
        logcat(f"Failed to load data from {path}: {traceback.format_exc()}")
        return None


def write(path: str, content: Any):
    try:
        dir_name = os.path.dirname(path)
        if not os.path.exists(dir_name):
            os.makedirs(dir_name, exist_ok=True)

        save_data = json.dumps(content, indent=4).encode("utf-8", errors="replace")
        with open(path, "wb") as file:
            file.write(save_data)
    except PermissionError as e:
        logcat(f"Have no permissions to edit {path}: {e}")
    except Exception as e:
        logcat(f"Failed to write data to {path}: {e}")


def get_platform(platform: int) -> Platform:
    if platform == 0:
        return Platform.NotSelected
    elif platform == 1:
        return Platform.Spotify
    elif platform == 2:
        return Platform.YandexMusic
    elif platform == 3:
        return Platform.SoundCloud
    elif platform == 4:
        return Platform.VkMusic
    elif platform == 5:
        return Platform.TgMusic
    else:
        return Platform.NotSelected
    

def get_songlink(platform: int) -> str:
    if platform == int(Platform.NotSelected.value[0]):
        return 'sc'
    elif platform == int(Platform.Spotify.value[0]):
        return 's'
    elif platform == int(Platform.YandexMusic.value[0]):
        return 'ya'
    elif platform == int(Platform.SoundCloud.value[0]):
        return 'sc'
    elif platform == int(Platform.VkMusic.value[0]):
        return 'sc'
    elif platform == int(Platform.TgMusic.value[0]):
        return 'i'
    else:
        return 'sc'


def get_download_link(platform: int, track_id: int) -> Optional[str]:
        songlink_codename = get_songlink(platform)
        songlink = requests.get(f"https://song.link/{songlink_codename}/{track_id}")
        if songlink.status_code == 200:
            youtube_link = re.findall(r"(https://(www\.)?youtube.com/.+?=.+?\")", songlink.text)
            soundcloud_link = re.findall(r"(https://(www\.)?soundcloud\.com/.+?\")", songlink.text)
            if soundcloud_link or youtube_link:
                return soundcloud_link[0][0][:-1] if soundcloud_link else youtube_link[0][0][:-1]
            else:
                return None
        else:
            return None


def copy(to_copy: str) -> bool:
    return AndroidUtilities.addToClipboard(to_copy)


def delete_file_delayed(path: str, delay: int=60):
    def action():
        try:
            time.sleep(delay)
            if os.path.exists(path):
                os.remove(path)
                logcat(f"Deleted temp file: {path}")
        except Exception as e:
            logcat(f"Delayed delete error: {e}")

    threading.Thread(target=action, daemon=True).start()


def _get_cache_file_path() -> Optional[str]:
    temp_dir_obj = get_temp_dir()
    if not temp_dir_obj:
        logcat("Could not get base temp directory for cache.")
        return None

    swaga_dir_path = os.path.join(temp_dir_obj.getAbsolutePath(), "swaga_temp")
    return os.path.join(swaga_dir_path, "cached_values.json")


def initialize_cached_platforms_values() -> List[Optional[str]]:
    empty_values = [DEFAULT_VALUE for _ in range(PLATFORMS_COUNT)]
    path = _get_cache_file_path()
    if path:
        write(path, empty_values)
        logcat("Cached values initialized in file.")
    else:
        logcat("Could not initialize cache file: path is invalid.")
    return empty_values


def is_cached_values_exist() -> bool:
    path = _get_cache_file_path()
    if not path:
        return False

    values_list = read(path)

    return isinstance(values_list, list) and len(values_list) == PLATFORMS_COUNT


def is_cached_value_exist(platform: int) -> bool:
    cached_value = get_cached_values()[platform]
    return cached_value is not None and cached_value != DEFAULT_VALUE


def get_cached_values() -> List[Optional[str]]:
    path = _get_cache_file_path()
    if not path:
        return [DEFAULT_VALUE for _ in range(PLATFORMS_COUNT)]

    exist_values = read(path)

    if not isinstance(exist_values, list) or len(exist_values) != PLATFORMS_COUNT:
        logcat("Cached values are missing or corrupted, re-initializing.")
        return initialize_cached_platforms_values()

    return exist_values


def get_cached_value(platform: int) -> Optional[str]:
    return get_cached_values()[platform]


def save_platform_value(platform: int, value: str):
    path = _get_cache_file_path()
    if not path:
        show_error("Cannot save value: cache storage is unavailable.")
        return

    exist_values = get_cached_values()

    if exist_values[platform] == value:
        logcat(f"Value '{value}' at index {platform} is already set.")
        return

    exist_values[platform] = value
    write(path, exist_values)

    if is_cached_value_exist(platform):
        show_success("New service value cached.")
        logcat(f"Saved value '{value}' at index {platform}.")


class ReSwagaPlugin(BasePlugin):
    def __init__(self):
        super().__init__()

        self.platform: Optional[BasePlatform] = None
        self.spinner: Optional[AlertDialogBuilder] = None
        self.info: Optional[AlertDialogBuilder] = None
        self.loading: Optional[AlertDialogBuilder] = None
        self.poller_enabled: Optional[bool] = None
        self.poller_lock: threading.Lock = threading.Lock()

    def on_plugin_load(self):
        try:
            self.add_on_send_message_hook()
            get_temp_dir()

            threading.Thread(target=self.check_resources, args=(False,)).start()
            # threading.Thread(target=read_remote_config, daemon=True).start()

            self.poller_enabled = any([
                self.get_setting("stream_bio_enabled", False),
                self.get_setting("fast_card_render", False)
            ])

            current_platform = self.get_setting("selected_platform", 0)
            if current_platform != int(Platform.NotSelected.value[0]):
                self.update_platform_object(current_platform, True)

            if not self.poller_enabled and self.enabled and not self.platform is None:
                self.start_poller()

            if self.get_setting("default_stream_text", DEFAULT_STREAM_TEXT) == DEFAULT_STREAM_TEXT:
                self.save_default_user_bio()

            if self.get_setting("enable_auth_data_cache", False):
                if not is_cached_values_exist():
                    initialize_cached_platforms_values()
                else:
                    if current_platform != int(Platform.NotSelected.value[0]):
                        cached_value = get_cached_value(current_platform)
                        current_value = self.get_setting("value", DEFAULT_VALUE)

                        if cached_value != current_value:
                            save_platform_value(current_platform, current_value)

            self.set_menu_items(False)

            logcat(f"Plugin loaded.")
        except Exception as e:
            import traceback
            logcat(traceback.format_exc())

    def on_plugin_unload(self):
        if self.poller_enabled:
            self.stop_poller()

        logcat(f"Plugin unloaded.")

    def create_settings(self):
        platforms = [p.value[1] for p in Platform]
        selected_platform = self.get_setting("selected_platform", 0)
        is_value_valid = self.is_platform_value_valid(selected_platform)

        settings = [
            Header(text=locale.Settings_Auth_Header),
            Selector(
                key="selected_platform",
                text=locale.Settings_Auth_Platform,
                icon="msg_tone_on",
                items=platforms,
                default=0,
                on_change=lambda new_value: self.update_platform_object(new_value, False)
            )
        ]

        if selected_platform == int(Platform.NotSelected.value[0]):
            return settings

        if selected_platform != int(Platform.TgMusic.value[0]):
            settings += [
                Input(
                    key="value",
                    text=locale.Settings_Auth_Value_Text if self.platform.value_text is None else self.platform.value_text,
                    on_change=lambda _: self.update_platform_object(self.get_setting("selected_platform", 0), True),
                    icon="msg_pin_code"
                ) if selected_platform != int(Platform.NotSelected.value[0]) and selected_platform != int(Platform.TgMusic.value[0]) else None
            ]

        if self.platform.pre_auth_settings:
            pre_auth_settings = self.platform.create_pre_auth_settings(self)
            if len(pre_auth_settings) > 0:
                settings += [ 
                    Header(text=get_platform(selected_platform).value[1]),
                    Divider() 
                ]
                settings += pre_auth_settings

        if not is_value_valid and selected_platform != int(Platform.TgMusic.value[0]):
            return settings

        advanced = self.get_setting('advanced_mode', False)

        if self.platform.additional_settings:
            additional_settings = self.platform.create_additional_settings(self)
            if len(additional_settings) > 0:
                settings += [
                    Divider(),
                    Header(
                        text=f"{get_platform(selected_platform).value[1]} - Additional settings"
                    ) 
                ]
                settings += additional_settings

        settings += [
            Divider(),

            Header(text=locale.Settings_CardSettings_Header),
            Input(
                key='cobalt_api_url',
                text=locale.Settings_CobaltApi_Text,
                subtext=locale.Settings_CobaltApi_Subtext,
                default=DEFAULT_COBALT_API_URL,
                icon='msg_instant_link'
            ),
            Selector(
                key="background",
                text=locale.Settings_BackgroundMode_Text,
                default=1,
                items=[
                    locale.Settings_BackgroundMode_Item_1,
                    locale.Settings_BackgroundMode_Item_2
                ],
                icon="msg_photos"
            ),
            Selector(
                key="font",
                text=locale.Settings_Font_Text,
                default=0,
                items=[
                    locale.Settings_Font_Item1,
                    locale.Settings_Font_Item2,
                    locale.Settings_Font_Item3
                ],
                icon="msg_photo_text_regular"
            ),
            Selector(
                key="platform_link",
                text=locale.Settings_PlatformLink_Text,
                default=1,
                items=[
                    locale.Settings_PlatformLink_Item_1,
                    locale.Settings_PlatformLink_Item_2,
                    locale.Settings_PlatformLink_Item_3
                ],
                icon="msg_link2"
            ) if selected_platform != int(Platform.TgMusic.value[0]) else None,
            Switch(
                key="songlink_link_include",
                text=locale.Settings_SongLinkInclude_Text,
                default=True,
                subtext=locale.Settings_SongLinkInclude_Subtext,
                icon="msg_language"
            ),
            Switch(
                key="fast_card_render",
                text=locale.Settings_FastCardRender_Text,
                default=False,
                subtext=locale.Settings_FastCardRender_Subtext,
                on_change=lambda new_value: self.set_fast_card_render_enabled(new_value),
                icon="boosts_solar"
            ),

            Switch(
                key="advanced_mode",
                text=locale.Setting_AdvancedMode_Text,
                default=False,
                subtext=locale.Setting_AdvancedMode_Subtext,
                icon="msg_palette"
            ),
            Text(
                text=locale.Setting_AdvancedMode_Title,
                icon="msg_download_settings",
                create_sub_fragment=self.create_customization_settings
            ) if advanced else None,

            Divider(),

            Header(text=locale.Settings_Stream_Header),
            Switch(
                key="stream_bio_enabled",
                text=locale.Settings_Stream_Text,
                default=False,
                subtext=locale.Settings_Stream_Subtext,
                on_change=lambda new_value: self.set_stream_bio_enabled(new_value),
                icon="msg_online"
            ),
            Text(
                text=locale.Setting_Stream_Title,
                icon="msg_download_settings",
                create_sub_fragment=self.create_stream_settings
            ),
            Divider(text=locale.Settings_Stream_Alert),

            Header(text=locale.Settings_Cache_Header),
            Switch(
                key="enable_auth_data_cache",
                text=locale.Setting_Cache_Enable_Text,
                icon="menu_clear_cache",
                default=False,
                on_change=lambda new_value: self.update_cache(new_value)
            ),
            Text(
                text=locale.Setting_Cache_DeleteCached,
                icon="msg_delete",
                on_click=lambda _: self.clear_cached_platforms_values()
            ) if self.get_setting("enable_auth_data_cache", False) else None,

            Divider(),

            Header(text=locale.Settings_Other_Header),
            Text(
                text=locale.Setting_Other_SourceCheck,
                icon="msg_noise_on",
                on_click=lambda _: self.check_resources(True, True)
            ),
            Text(
                text=locale.Setting_Other_ForceDownload,
                icon="msg_download",
                on_click=lambda _: threading.Thread(target=self.download_resources, args=(True,), daemon=True).start()
            ),
            Text(
                text=locale.Setting_Other_Donate,
                icon="msg_ton",
                accent=True,
                on_click=lambda view: self.show_info_alert(
                    title=locale.Alert_Donate_Title,
                    message=locale.Alert_Donate_Text,
                    positive_text="OK",
                    neutral_text=locale.Alert_Donate_Button,
                    neutral_listener=lambda: copy("UQBVxjueXqAEpALX_b0yr-ytXN26LOTpSBn26b9VRHKrmm5F")
                )
            )
        ]

        return settings

    def create_customization_settings(self):
        instant_card = self.get_setting("fast_card_render", False)
        return [
            Input(
                key="background_color",
                text=locale.Settings_BackgroundColor_Text,
                default=DEFAULT_COLOR["background_color"],
                subtext=locale.Settings_BackgroundColor_Subtext,
                icon="menu_feature_custombg",
                on_change=lambda new_value: self.is_hex_valid(new_value, "background_color")
            ) if self.get_setting("background", 1) == 1 else None,
            Input(
                key="title_text_color",
                text=locale.Settings_AccentColor_Text,
                default=DEFAULT_COLOR["title_text_color"],
                subtext=locale.Settings_AccentColor_Subtext,
                icon="msg_photo_text_framed",
                on_change=lambda new_value: self.is_hex_valid(new_value, "title_text_color")
            ),
            Input(
                key="subtext_color",
                text=locale.Settings_SecondaryColor_Text,
                default=DEFAULT_COLOR["subtext_color"],
                subtext=locale.Settings_SecondaryColor_Subtext,
                icon="msg_photo_text_framed2",
                on_change=lambda new_value: self.is_hex_valid(new_value, "subtext_color")
            ),
            Input(
                key="instant_subtext",
                text=locale.Settings_InstantCardSubtext_Text,
                default=DEFAULT_INSTANT_SUBTEXT,
                subtext=locale.Settings_InstantCardSubtext_Subtext,
                icon="menu_feature_intro"
            ) if instant_card else None,
            Input(
                key="instant_main_text",
                text=locale.Settings_InstantCardMainText_Text,
                default=DEFAULT_INSTANT_MAIN_TEXT,
                subtext=locale.Settings_InstantCardMainText_Subtext,
                icon="menu_feature_cover"
            ) if instant_card else None,
        ]

    def create_stream_settings(self):
        stream_places: List[str] = [locale.Setting_TrackStream_Item1]
        if get_user_config().isPremium():
            stream_places.append(locale.Setting_TrackStream_Item2)

        return [
            Selector(
                key="stream_place",
                text=locale.Setting_TrackStream_Text,
                default=0,
                items=stream_places,
                icon="menu_premium_location" if self.get_setting("stream_place", 0) else "msg_openprofile"
            ),
            Input(
                key="default_stream_text",
                text=locale.Settings_InStream_Text,
                default=DEFAULT_STREAM_TEXT,
                subtext=locale.Settings_InStream_Subtext,
                icon="msg_photo_text_framed3"
            ),
            Input(
                key="track_display_format",
                text=locale.Settings_FormatInStream_Text,
                default=DEFAULT_STREAM_STRING,
                subtext=locale.Settings_FormatInStream_Subtext,
                icon="msg_view_file"
            ),
        ]

    def set_menu_items(self, remove: bool):
        def on_menu_item_click(new_platform: int):
            self.set_menu_items(True)
            self.set_setting('selected_platform', new_platform)
            platform: Platform = get_platform(new_platform)

            if self.get_setting('selected_platform', int(Platform.NotSelected.value[0])) == new_platform:
                self.update_platform_object(new_platform, False)
                self.set_menu_items(False)
                show_success(locale.MenuItem_Service_Success.format(platform.value[1]))
            else:
                show_error(locale.MenuItem_Service_Fail.format(pl.value[1]))

        selected_platform = self.get_setting('selected_platform', int(Platform.NotSelected.value[0]))
        platforms = [p for p in Platform if p.value[0] != selected_platform and p.value[0] != int(Platform.NotSelected.value[0])]

        for pl in platforms:
            cleared_item_name: str = str(pl.value[1]).lower().strip().replace(" ", "").replace(".", "")
            item_id: str = f'{cleared_item_name}-{pl.value[0]}'

            if remove:
                self.remove_menu_item(item_id)
            else:
                self.add_menu_item(
                    menu_item_data=MenuItemData(
                        menu_type=MenuItemType.CHAT_ACTION_MENU,
                        item_id=item_id,
                        icon='msg_tone_on',
                        text=locale.MenuItem_Service_Select_Text.format(pl.value[1]),
                        subtext=locale.MenuItem_Service_Select_Subtext,
                        on_click=lambda _, p=pl: on_menu_item_click(int(p.value[0]))
                    )
                )

    def on_send_message_hook(self, account: int, params: Any):
        if hasattr(params, 'message') and isinstance(params.message, str):
            text = str(params.message)
            if text.startswith('.now') or text.startswith('. now'):
                platform = self.get_setting("selected_platform", 0)

                if self.is_args_not_valid(platform):
                    return HookResult(strategy=HookStrategy.CANCEL)

                if text == ".now" or text == ". now":
                    threading.Thread(
                        target=self.send_card_message,
                        args=(params,),
                        daemon=True
                    ).start()

                elif text == ".nowt" or text == ". nowt":
                    if not self.platform.can_download_track:
                        show_info(locale.Check_Platform_DownloadNotAvailable)
                        return HookResult(strategy=HookStrategy.CANCEL)

                    threading.Thread(
                        target=self.send_audio_message,
                        args=(params.peer, params.replyToMsg, params.replyToTopMsg),
                        daemon=True
                    ).start()

                return HookResult(strategy=HookStrategy.CANCEL)

            else:
                return HookResult(strategy=HookStrategy.DEFAULT)

        elif hasattr(params, 'caption') and isinstance(params.caption, str):
            metadata_flag = f"{__name__}_flag_metadata"
            markdown_flag = f"{__name__}_flag_markdown"

            if metadata_flag in params.caption:
                if self.poller_enabled:
                    track = self.platform.now_track
                else:
                    track = self.platform.get_track()

                for i in range(params.document.attributes.__str__().split(",").__len__()):
                    if "title" in dir(params.document.attributes.get(i)):
                        params.document.attributes.get(i).title = track.title if track.active else f"[{__name__}] ERROR"
                        params.document.attributes.get(i).performer = ", ".join(track.artist) if track.active else locale.Track_Not_Active
                        params.document.attributes.get(i).duration = track.duration if track.active else 0

                markdown = markdown_flag in params.caption
                if metadata_flag in params.caption:
                    params.caption = params.caption.replace(" " + metadata_flag, "")

                if markdown:
                    params.caption = params.caption.replace(" " + markdown_flag, "")
                    caption = parse_markdown(params.caption)
                    params.caption = caption.text
                    params.entities = ArrayList()
                    for i in caption.entities:
                        params.entities.add(i.to_tlrpc_object())

                return HookResult(HookStrategy.MODIFY, params=params)
            else:
                return HookResult(strategy=HookStrategy.DEFAULT)

        else:
            return HookResult(strategy=HookStrategy.DEFAULT)

    def on_app_event(self, event_type: AppEvent):
        if any([self.get_setting("stream_bio_enabled", False), self.get_setting("fast_card_render", False)]):
            if event_type in [AppEvent.PAUSE, AppEvent.STOP]:
                self.stop_poller()
            elif event_type in [AppEvent.RESUME, AppEvent.START]:
                self.start_poller()

    def is_platform_value_valid(self, platform: int) -> bool:
        value = str(self.get_setting("value", DEFAULT_VALUE))
        if platform == int(Platform.YandexMusic.value[0]):
            return not len(value) <= 4 and not value in ["", None, DEFAULT_VALUE]
        elif platform == int(Platform.TgMusic.value[0]):
            return True
        else:
            return not value in ["", None, DEFAULT_VALUE]

    def update_cache(self, new_value: bool):
        initialize_cached_platforms_values()
        if new_value:
            save_platform_value(
                self.get_setting("selected_platform", int(Platform.NotSelected.value[0])),
                self.get_setting("value", DEFAULT_VALUE)
            )

    def clear_cached_platforms_values(self):
        initialize_cached_platforms_values()
        cached_values = get_cached_values()
        values = [cl for cl in cached_values if cl == DEFAULT_VALUE]
        if len(values) == PLATFORMS_COUNT:
            save_platform_value(
                self.get_setting("selected_platform", int(Platform.NotSelected.value[0])),
                self.get_setting("value", DEFAULT_VALUE)
            )
            show_success(locale.CachedAuthData_Clear_Success)
        else:
            show_error(locale.CachedAuthData_Clear_Error)

    def download_track_with_cobalt(self, url: str, track: Track) -> Optional[str]:
        api_url: str = self.get_setting('cobalt_api_url', DEFAULT_COBALT_API_URL)
        temp_dir = get_temp_dir()
        payload: Dict[str, str] = {
            "url": url,
            "downloadMode": "audio",
            "audioBitrate": "320",
            "audioFormat": "best"
        }
        headers: Dict[str, str] = {
            "Accept": "application/json",
            "Content-Type": "application/json"
        }

        try:
            try:
                response = requests.post(f"{api_url}/", json=payload, headers=headers, timeout=30)
                response.raise_for_status()
            except Exception as e:
                run_on_ui_thread(lambda: self.dismiss_spinner())
                BulletinHelper.show_error(locale.Bulletin_InvalidCobaltResponse)
                logcat(f"Cobalt Request Error: {e} | data = {payload}")
                return None

            data = response.json()
            logcat(f"Cobalt Response Data: {data}")

            status = data.get("status")

            if status == "error":
                code = data.get("error", {}).get("code", "Unknown error")
                BulletinHelper.show_error(locale.Bulletin_CobaltErrorCode.format(code))
                return None

            elif status == "picker":
                items = data.get("picker", [])
                if not items:
                    BulletinHelper.show_error(locale.Bulletin_NoItemsToDownload)
                    return None
                item = items[0]
                direct_url = item.get("url")
                original_filename = item.get("filename")

            elif status in ["stream", "redirect", "success"]:
                direct_url = data.get("url")
                original_filename = data.get("filename")

            else:
                logcat(f"Cobalt Warning: Received an unhandled status: '{status}'")
                BulletinHelper.show_error(locale.Bulletin_InvalidCobaltResponse)
                return None

            if not direct_url:
                BulletinHelper.show_error(locale.Bulletin_InvalidCobaltResponse)
                return None

            file_extension = original_filename.split('.')[-1] if original_filename and '.' in original_filename else 'mp3'
            filename: str = f"{track.title} (via {__name__}).{file_extension}"
            file_path: str = File(temp_dir, filename).getAbsolutePath()

            logcat(f"Downloading audio in background thread: {filename}")

            try:
                track_resp = requests.get(direct_url, stream=True, timeout=60)
                track_resp.raise_for_status()
            except Exception as e:
                run_on_ui_thread(lambda: self.dismiss_spinner())
                logcat(f"Cobalt Download Error: {e}")
                BulletinHelper.show_error(locale.Bulletin_InvalidCobaltResponse)
                return None

            with open(file_path, "wb") as f:
                for chunk in track_resp.iter_content(chunk_size=8192):
                    f.write(chunk)

            try:
                size = os.path.getsize(file_path)
                logcat(f"Downloaded audio: {filename}, size: {size}")
            except Exception as dbg_e:
                logcat(f"Download error: {dbg_e}")

            return file_path
        except Exception as _:
            import traceback
            logcat(traceback.format_exc())

    def send_card_message(self, msg_params):
        try:
            run_on_ui_thread(lambda: self.show_spinner())
            params = {
                "message": None,
                "peer": msg_params.peer
            }

            if self.poller_enabled:
                track = self.platform.now_track
            else:
                track = self.platform.get_track()

            if track is None:
                run_on_ui_thread(lambda: self.dismiss_spinner())
                show_error(locale.Track_Not_Active)
                return

            if not track.active:
                run_on_ui_thread(lambda: self.dismiss_spinner())
                show_error(locale.Track_Not_Active)
                return

            temp_dir = get_temp_dir()
            temp_file_path = None

            answer = self._make_card() if not (self.get_setting("fast_card_render", False)) else True
            if answer:
                temp_file_path = File(temp_dir, f"now_{__name__}.png").getAbsolutePath()

            if temp_file_path in ["", None]:
                run_on_ui_thread(lambda: self.dismiss_spinner())
                show_error(locale.Track_Not_Active)
                return

            generated_photo = get_send_messages_helper().generatePhotoSizes(temp_file_path, None)

            if generated_photo is None:
                run_on_ui_thread(lambda: self.dismiss_spinner())
                show_error(locale.Track_Not_Active)
                return

            params["photo"] = generated_photo
            params["path"] = temp_file_path
            params["replyToMsg"] = msg_params.replyToMsg
            params["replyToTopMsg"] = msg_params.replyToTopMsg

            if not track.active:
                run_on_ui_thread(lambda: self.dismiss_spinner())
                show_error(locale.Track_Not_Active)
                return

            platform = self.get_setting("selected_platform", 0)

            platform_link: int = self.get_setting("platform_link", 1)
            platform_link_added: bool = False

            songlink: bool = self.get_setting("songlink_link_include", True)
            songlink_added: bool = False

            caption: str = ""

            if (platform_link and platform_link != 0) and platform != int(Platform.TgMusic.value[0]):
                link = track.link if (platform_link == 1 or track is None) else track.album
                caption += locale.Message_CaptionLink_Text.format(get_platform(platform).value[1], link)
                platform_link_added = True

            if songlink and songlink != 0:
                if platform_link_added:
                    caption += locale.Message_CaptionDivider

                caption += locale.Message_CaptionSongLink_Text.format(f"https://song.link/{get_songlink(platform)}/{track.track_id}")
                songlink_added = True

            if any([platform_link_added, songlink_added]):
                emoji: str = random.choice(["[üéµ](5188621441926438751) | ", "[üé∂](5188705588925702510) | "])
                caption = emoji + caption

                parsed_caption = parse_markdown(caption)
                params["caption"] = parsed_caption.text
                params["entities"] = set()

                for i in parsed_caption.entities:
                    params["entities"].add(i.to_tlrpc_object())

            run_on_ui_thread(lambda: send_message(params))
            run_on_ui_thread(lambda: self.dismiss_spinner())
        except Exception as _:
            run_on_ui_thread(lambda: self.dismiss_spinner())
            show_error(locale.Track_Not_Active)
            import traceback
            logcat(f'send_card_message: {traceback.format_exc()}')

    def send_audio_message(self, dialog_id, reply_to_msg, reply_to_top_msg):
        run_on_ui_thread(lambda: self.show_spinner())

        if self.poller_enabled:
            track = self.platform.now_track
        else:
            track = self.platform.get_track()

        if not track.active:
            run_on_ui_thread(lambda: self.dismiss_spinner())
            show_error(locale.Track_Not_Active)
            return

        url = track.download_url

        try:
            if not url is None:
                temp_dir = get_temp_dir()
                temp_dir_name = "swaga_temp"

                ext = os.path.splitext(url)[1] or ".mp3"
                filename = f"{track.title}{ext}"
                file_path = File(temp_dir, filename).getAbsolutePath()
                resp = requests.get(url, stream=True, timeout=60)
                resp.raise_for_status()

                with open(file_path, 'wb') as f:
                    for chunk in resp.iter_content(8192):
                        f.write(chunk)

                ext_root = ApplicationLoader.applicationContext.getExternalCacheDir()
                plugin_dir = File(ext_root, temp_dir_name)

                if not plugin_dir.exists() and not plugin_dir.mkdirs():
                    pass

                ext_path = File(plugin_dir, File(file_path).getName()).getAbsolutePath()

                with open(file_path, 'rb') as fin, open(ext_path, 'wb') as fout:
                    fout.write(fin.read())

                delete_file_delayed(file_path)
            else:
                new_url = get_download_link(
                    platform=self.get_setting('selected_platform', int(Platform.NotSelected.value[0])),
                    track_id=track.track_id
                )

                if new_url in ['', None]:
                    run_on_ui_thread(lambda: self.dismiss_spinner())
                    return
                
                ext_path = self.download_track_with_cobalt(new_url, track)
                if ext_path in ['', None] or not os.path.exists(ext_path):
                    run_on_ui_thread(lambda: self.dismiss_spinner())
                    return

            account = get_account_instance()
            mime = "audio/mpeg"
            platform = self.get_setting("selected_platform", 0)

            platform_link: int = self.get_setting("platform_link", 1)
            platform_link_added: bool = False

            songlink: bool = self.get_setting("songlink_link_include", True)
            songlink_added: bool = False

            caption: str = ""

            if (platform_link and platform_link != 0) and platform != int(Platform.TgMusic.value[0]):
                link = track.link if (platform_link == 1 or track is None) else track.album
                caption += locale.Message_CaptionLink_Text.format(get_platform(platform).value[1], link)
                platform_link_added = True

            if songlink and songlink != 0:
                if platform_link_added:
                    caption += locale.Message_CaptionDivider

                caption += locale.Message_CaptionSongLink_Text.format(f"https://song.link/{get_songlink(platform)}/{track.track_id}")
                songlink_added = True

            if any([platform_link_added, songlink_added]):
                emoji: str = random.choice(["[üéµ](5188621441926438751) | ", "[üé∂](5188705588925702510) | "])
                caption = emoji + caption

            markdown_need = any([platform_link_added, songlink_added])

            SendMessagesHelper.prepareSendingDocument(
                account,
                ext_path,
                ext_path,
                None,
                f"{caption} {__name__}_flag_metadata{f' {__name__}_flag_markdown' if markdown_need else ''}",
                mime,
                dialog_id,
                reply_to_msg,
                reply_to_top_msg,
                None, None, None, True, 0, None, None, 0, False
            )

            run_on_ui_thread(lambda: self.dismiss_spinner())
            delete_file_delayed(ext_path)
        except Exception as _:
            run_on_ui_thread(lambda: self.dismiss_spinner())
            show_error(locale.Track_Not_Active)

    def update_platform_object(self, new_platform: int, value: bool):
        cache_enabled: bool = self.get_setting("enable_auth_data_cache", False)

        if not value:
            if cache_enabled and is_cached_value_exist(new_platform):
                self.set_setting("value", get_cached_value(new_platform))
            else:
                self.set_setting("value", DEFAULT_VALUE)

        token = self.get_setting("value", DEFAULT_VALUE)
        token_default_values = ["", None, DEFAULT_VALUE]

        if cache_enabled and (not new_platform in [int(Platform.NotSelected.value[0]), int(Platform.TgMusic.value[0])]):
            cached_value = get_cached_value(new_platform)
            if token not in token_default_values and token != cached_value:
                save_platform_value(new_platform, token)

        if new_platform == int(Platform.NotSelected.value[0]):
            self.platform = None

        elif new_platform == int(Platform.Spotify.value[0]):
            self.platform = Spotify(token)

        elif new_platform == int(Platform.YandexMusic.value[0]):
            custom_api_url: Optional[str] = self.get_setting("yandex_custom_api", None) if self.get_setting("enable_yandex_custom_api", False) else None
            self.platform = YandexMusic(token, custom_api_url)

        elif new_platform == int(Platform.SoundCloud.value[0]):
            self.platform = SoundCloud(token)

        elif new_platform == int(Platform.VkMusic.value[0]):
            self.platform = VkMusic(token, self.get_setting('vk_music_id', None))

        elif new_platform == int(Platform.TgMusic.value[0]):
            self.platform = TgMusic(token)

        else:
            logcat(f"Unknown platform ({new_platform})")

        self.stop_poller()

        if self.get_setting("default_stream_text", DEFAULT_STREAM_TEXT) == DEFAULT_STREAM_TEXT:
            self.save_default_user_bio()

        self.set_stream_text(True)

        stream_bio_enabled: bool = self.get_setting('stream_bio_enabled', False)
        fast_card_render: bool = self.get_setting('fast_card_render', False)

        if token in token_default_values:
            self.stop_poller()
        elif token not in token_default_values and any([stream_bio_enabled, fast_card_render]):
            self.start_poller()
        else:
            logcat("Unknown token state, can't do anything")

    def is_args_not_valid(self, platform: int) -> bool:
        if platform == int(Platform.NotSelected.value[0]) or self.platform is None:
            show_error(
                message=locale.Check_Platform_NotSelected,
                on_click=lambda: open_plugin_settings(),
                button_text=locale.Check_Platform_NotSelected_Button
            )
            return True

        if self.platform.need_special_platform_args_check and self.platform.special_platform_args_check(self):
            return True

        elif not self.is_platform_value_valid(platform):
            show_error(
                message=locale.Check_Value_NotValid,
                on_click=lambda: open_plugin_settings(),
                button_text=locale.Check_Value_NotValid_Button
            )
            return True

        elif not self.check_resources(True, False):
            show_error(
                message=locale.Check_Resources_NotFound,
                on_click=lambda: self.download_resources(True),
                button_text=locale.Check_Resources_NotFound_Button
            )
            return True

        else:
            return False

    def set_fast_card_render_enabled(self, enable: bool):
        if enable:
            self.start_poller()
        else:
            if not self.get_setting("stream_bio_enabled", False):
                self.stop_poller()

    def save_default_user_bio(self):
        stream_place = self.get_setting("stream_place", 0)
        default_stream_text = self.get_setting("default_stream_text", DEFAULT_STREAM_TEXT)

        client_user_id = get_user_config().getClientUserId()
        if client_user_id is None or client_user_id == 0:
            logcat("Client userId not found")
            return

        user_full = get_messages_controller().getUserFull(client_user_id)
        if user_full is None:
            logcat("User fullInfo not found")
            return

        if stream_place == 0:  # current bio
            if user_full.about and user_full.about != default_stream_text:
                if not str(user_full.about).startswith("üéµ | "):
                    self.set_setting("default_stream_text", user_full.about)

        elif stream_place == 1:  # current address
            if user_full.business_location and user_full.business_location.address and user_full.business_location.address != default_stream_text:
                if not str(user_full.business_location.address).startswith("üéµ | "):
                    self.set_setting("default_stream_text", user_full.business_location.address)

        else:  # Index out of range
            self.set_setting("default_stream_text", DEFAULT_STREAM_TEXT)

    def set_stream_bio_enabled(self, enable: bool):
        if enable:
            self.start_poller()
            self.save_default_user_bio()
            self.set_stream_text(False)
        else:
            self.set_stream_text(True)
            if not self.get_setting("fast_card_render", False):
                self.stop_poller()

    def set_stream_text(self, default: bool):
        stream_place = self.get_setting("stream_place", 0)

        client_user_id = get_user_config().getClientUserId()
        if client_user_id is None or client_user_id == 0:
            logcat("Client userId not found")
            return

        user_full = get_messages_controller().getUserFull(client_user_id)
        if user_full is None:
            logcat("User fullInfo not found")
            return

        current_text: str = ""

        if stream_place == 0:  # current bio
            if user_full.about:
                current_text = user_full.about

        elif stream_place == 1:  # current address
            if user_full.business_location and user_full.business_location.address:
                current_text = user_full.business_location.address

        else:
            logcat("Index out of range. Can't get current bio text.")

        if self.platform is None or self.platform.now_track is None:
            return

        text_to_set: str

        if default:
            text_to_set = self.get_setting("default_stream_text", DEFAULT_STREAM_TEXT)
        else:
            if self.platform and self.platform.now_track and self.platform.now_track.active:
                text_to_set = self.get_setting("track_display_format", DEFAULT_STREAM_STRING)
                text_to_set = text_to_set.replace("{title}", self.platform.now_track.title)
                text_to_set = text_to_set.replace("{artists}", ", ".join(self.platform.now_track.artist))
            else:
                logcat("Poller check: No active track to display. No changes needed.")
                return

        final_text_to_set = text_to_set
        if stream_place == 0:
            max_len = 140 if get_user_config().isPremium() else 70
            final_text_to_set = text_to_set[:max_len]
        elif stream_place == 1:
            final_text_to_set = text_to_set[:96]

        if final_text_to_set == current_text:
            logcat("No need to update bio.")
            return

        if stream_place == 0:  # in bio
            # online update
            request = TL_account.updateProfile()
            request.flags = 4
            request.about = final_text_to_set

            # local update
            user_full.flags = 2
            user_full.about = final_text_to_set

        elif stream_place == 1:  # in business location
            # online update
            request = TL_account.updateBusinessLocation()
            request.flags = 1
            request.address = final_text_to_set

            # local update
            user_full.flags2 = 2
            user_full.business_location = TLRPC.TL_businessLocation()
            user_full.business_location.address = final_text_to_set

        else:  # out of range
            logcat("Stream place index out of range.")
            return

        if request:
            try:
                send_request(request, ())
                get_messages_storage().updateUserInfo(user_full, False)
                logcat(f"Updating bio to \"{text_to_set}\"...")
            except Exception as e:
                logcat(f"set_stream_text exception: {e}")

    def poller(self):
        try:
            while self.poller_enabled:
                logcat("Polling...")

                stream_bio_enabled: bool = self.get_setting("stream_bio_enabled", False)
                fast_card_render: bool = self.get_setting("fast_card_render", False)

                if not any([stream_bio_enabled, fast_card_render]):
                    logcat("Stream Bio and Fast Card Render is disabled, stopping poller...")
                    break

                stream_place = self.get_setting("stream_place", 0)

                if stream_bio_enabled and stream_place == 0:
                    sleep_time = 10
                elif stream_bio_enabled and stream_place == 1:
                    sleep_time = 5
                else:
                    sleep_time = 10

                if self.platform:
                    self.platform.get_track()

                    if stream_bio_enabled:
                        self.set_stream_text(False)

                    if fast_card_render:
                        if self.platform.memory_id != self.platform.now_track.track_id:
                            logcat("MemoryID not equals with Current trackID, making new card.")
                            self.platform.memory_id = self.platform.now_track.track_id
                            self._make_card()
                        else:
                            logcat("MemoryID equals with Current trackID, no need to make new card.")
                else:
                    logcat("Platform is None, stopping poller...")
                    return

                time.sleep(sleep_time)

            self.stop_poller()
        except Exception as e:
            logcat(f"poller exception: {e}")

    def start_poller(self):
        with self.poller_lock:
            if self.poller_enabled:
                logcat("Poller is already enabled.")
                return

            self.poller_enabled = True
            threading.Thread(target=self.poller, daemon=True).start()
            logcat("Poller started.")

    def stop_poller(self):
        with self.poller_lock:
            if not self.poller_enabled:
                return

            self.poller_enabled = False
            logcat("Poller disabled. It will stop after the current cycle.")

        if self.get_setting("stream_bio_enabled", False):
            self.set_stream_text(True)

    def _make_card(self):
        try:
            track = self.platform.now_track
            temp_dir = get_temp_dir()
            font_family = self.get_setting("font", 0)
            font_family = FONTS[font_family]
            width, height = 1440, 600

            advanced_mode = self.get_setting("advanced_mode", False)
            if not advanced_mode:
                background_color = DEFAULT_COLOR["background_color"]
                title_text_color = DEFAULT_COLOR["title_text_color"]
                subtext_color = DEFAULT_COLOR["subtext_color"]
            else:
                background_color = self.get_setting("background_color", DEFAULT_COLOR["background_color"])
                title_text_color = self.get_setting("title_text_color", DEFAULT_COLOR["title_text_color"])
                subtext_color = self.get_setting("subtext_color", DEFAULT_COLOR["subtext_color"])

            if not track.active:
                if locale.language == 'ru' and font_family == "Circular":
                    font_family = "Onest"

                card = Image.new('RGB', (width, height), background_color)
                draw = ImageDraw.Draw(card)

                regular_plugin_font = File(temp_dir, f"{font_family}-Regular.ttf").getAbsolutePath()
                bold_plugin_font = File(temp_dir, f"{font_family}-Bold.ttf").getAbsolutePath()
                plugin_font = ImageFont.truetype(regular_plugin_font, 40)
                not_active_font = ImageFont.truetype(bold_plugin_font, 80)

                draw.text(
                    xy = (width // 2, 45),
                    text = __name__,
                    font=plugin_font,
                    fill=title_text_color,
                    align="center",
                    anchor="mm"
                )

                draw.text(
                    xy = (width // 2, height // 2),
                    text = "player_not_active_text",
                    font=not_active_font,
                    fill=title_text_color,
                    align="center",
                    anchor="mm"
                )

                filename = f"now_{__name__}.png"
                temp_photo_path = File(temp_dir, filename).getAbsolutePath()
                card.save(temp_photo_path)
                return temp_photo_path

            background_setting = self.get_setting("background", 1)

            try:
                thumb = requests.get(track.thumb, stream=True).raw
            except:
                thumb = requests.get(EMPTY_TRACK_COVER, stream=True).raw

            background = Image.open(thumb)
            thumbnail = background.copy()

            if background_setting == 0:
                background = background.resize((width, width)).crop((0, (width - height) // 2, width, width)).filter(
                    ImageFilter.GaussianBlur(radius=14))
                background = ImageEnhance.Brightness(background).enhance(0.3)
                card = Image.new('RGB', (width, height), background_color)
                card.paste(background, (0, 0))
            elif not advanced_mode:
                img = background.resize((16, 16), Resampling.LANCZOS)
                pixels = img.load()
                l_width, l_height = img.size

                for y in range(l_height):
                    for x in range(l_width):
                        if img.mode == 'L':
                            r = pixels[x, y]
                            r = math.pow(r / 255.0, 1 / 2.2) * 255.0
                            pixels[x, y] = int(r)
                        else:
                            r, g, b = pixels[x, y][:3]
                            r = math.pow(r / 255.0, 1 / 2.2) * 255.0
                            g = math.pow(g / 255.0, 1 / 2.2) * 255.0
                            b = math.pow(b / 255.0, 1 / 2.2) * 255.0
                            if img.mode == 'RGB':
                                pixels[x, y] = (int(r), int(g), int(b))
                            elif img.mode == 'RGBA':
                                a = pixels[x, y][3]
                                pixels[x, y] = (int(r), int(g), int(b), a)

                if img.mode == 'L':
                    img = img.convert('RGB')
                elif img.mode == 'RGBA':
                    rgb_img = Image.new('RGB', img.size)
                    rgb_img.paste(img, mask=img.split()[3])
                    img = rgb_img

                pixels = list(img.getdata())
                i_width, i_height = img.size

                if img.mode == 'RGB':
                    total_r, total_g, total_b = 0, 0, 0
                    darkness_index = 1.9
                    for r, g, b in pixels:
                        total_r += int(r // darkness_index)
                        total_g += int(g // darkness_index)
                        total_b += int(b // darkness_index)
                    count = i_width * i_height
                    average = (total_r // count, total_g // count, total_b // count)
                else:
                    total = sum(pixels)
                    average = (total // (i_width * i_height),) * 3
                card = Image.new('RGB', (width, height), average)

            else:
                card = Image.new('RGB', (width, height), background_color)

            thumbnail = thumbnail.resize((450, 450))
            mask = Image.new('L', thumbnail.size, 0)
            draw = ImageDraw.Draw(mask)
            draw.rounded_rectangle((0, 0, *thumbnail.size), 30, fill=255)
            thumbnail = thumbnail.copy()
            thumbnail.putalpha(mask)
            card.paste(thumbnail, (75, 75), thumbnail)
            draw = ImageDraw.Draw(card)
            local_font_family = None

            if re.findall(r"[–ê-–Ø–∞-—è–Å—ë]", track.title) and font_family == "Circular":
                local_font_family = "Onest"

            title_font_file = File(temp_dir, f"{local_font_family if local_font_family else font_family}-Bold.ttf")
            title_font = ImageFont.truetype(title_font_file.getAbsolutePath(), 60)

            x, y = 590, 85
            artists_plus_y = 0
            lines = textwrap.wrap(track.title, width=21)

            if len(lines) > 1:
                lines[1] = lines[1] + "..." if len(lines) > 2 else lines[1]
                artists_plus_y = 70
            else:
                pass

            lines = lines[:2]

            for line in lines:
                draw.text((x, y), line, font=title_font, fill=title_text_color)
                y += 70

            local_font_family = None

            if re.findall(r"[–ê-–Ø–∞-—è–Å—ë]", "".join(track.title)) and font_family == "Circular":
                local_font_family = "Onest"

            artist_font_file = File(temp_dir, f"{local_font_family if local_font_family else font_family}-Regular.ttf")
            artist_font = ImageFont.truetype(artist_font_file.getAbsolutePath(), 40)
            artists = textwrap.wrap(" ‚Ä¢ ".join(track.artist), width=32)
            if len(artists) > 1:
                if "‚Ä¢" in artists[0][-2:]:
                    artists[0] = artists[0][:artists[0].rfind("‚Ä¢") - 1]
                artists[0] = artists[0]
            artists = artists[0]

            draw.text((590, 170 + artists_plus_y), artists, subtext_color, font=artist_font)
            if not (self.get_setting("fast_card_render", False)) and track.progress:
                progress_bar_empty = Image.new('RGBA', (width - 665, 10), (0, 0, 0, 0))

                progress_draw = ImageDraw.Draw(progress_bar_empty)
                progress_draw.rounded_rectangle(
                    xy = (0, 0, *progress_bar_empty.size),
                    radius = 7,
                    fill=subtext_color
                )
                progress_draw.rounded_rectangle(
                    xy = (0, 0, progress_bar_empty.width * (track.progress / track.duration), 10),
                    radius = 7,
                    fill=title_text_color
                )
                card.paste(progress_bar_empty, (590, 460), progress_bar_empty)

                timers_font_path = File(temp_dir, f"{font_family}-Regular.ttf").getAbsolutePath()
                timers_font = ImageFont.truetype(timers_font_path, 30)

                draw.text(
                    xy = (590, 490),
                    text = f"{datetime.datetime.fromtimestamp(track.progress).strftime('%M:%S')}",
                    fill = subtext_color,
                    font=timers_font,
                    anchor="la"
                )
                draw.text(
                    xy = (1365, 490),
                    text = f"{datetime.datetime.fromtimestamp(track.duration).strftime('%M:%S')}",
                    fill = subtext_color,
                    font=timers_font,
                    anchor="ra"
                )
            else:
                local_font_family = None

                if advanced_mode:
                    subtext = self.get_setting("instant_subtext", "powered by")
                    maintext = self.get_setting("instant_main_text", __name__)
                else:
                    subtext = "powered by"
                    maintext = __name__

                subtext = subtext[:26] + "..." if len(subtext) > 26 else subtext
                maintext = maintext[:21] + "..." if len(maintext) > 21 else maintext

                ru_flag_subtext = True if re.findall(r"[–ê-–Ø–∞-—è–Å—ë]", subtext) else False
                ru_flag_maintext = True if re.findall(r"[–ê-–Ø–∞-—è–Å—ë]", maintext) else False

                if ru_flag_subtext and font_family == "Circular":
                    local_font_family = "Onest"

                info_font_file = File(temp_dir, f"{local_font_family if local_font_family else font_family}-Regular.ttf")
                info_font = ImageFont.truetype(info_font_file.getAbsolutePath(), 42)
                local_font_family = None

                if ru_flag_maintext and font_family == "Circular":
                    local_font_family = "Onest"

                device_font_file = File(temp_dir, f"{local_font_family if local_font_family else font_family}-Bold.ttf")
                device_font = ImageFont.truetype(device_font_file.getAbsolutePath(), 52)

                draw.text((590, 415), subtext, subtext_color, font=info_font, anchor="ls")
                draw.text((590, 485), maintext, title_text_color, font=device_font, anchor="ls")

            filename = f"now_{__name__}.png"
            temp_photo_path = File(temp_dir, filename).getAbsolutePath()
            card.save(temp_photo_path)

            return temp_photo_path
        except Exception as _:
            import traceback
            logcat(f'Failed generate card: {traceback.format_exc()}')
            return

    def is_hex_valid(self, new: str, variable_name: str):
        if not re.match("^#[A-Fa-f0-9]{6}$", new):
            run_on_ui_thread(lambda: self.show_info_alert(title=locale.Alert_HEX_Title, message=locale.Alert_HEX_Text))
            self.set_setting(variable_name, DEFAULT_COLOR[variable_name])

    def check_resources(self, redownload_resources: bool, show_success: bool) -> bool:
        try:
            temp = get_temp_dir()
            if not temp:
                logcat("Temp directory is none.")
                return False

            existing_files = {f.getName() for f in temp.listFiles()}

            all_resources_exist = True
            for resource_name in RESOURCES:
                if resource_name not in existing_files:
                    logcat(f"Resource missing: {resource_name}")
                    all_resources_exist = False
                    break

            if all_resources_exist:
                if show_success:
                    self.show_info_alert(title=locale.SourceSuccess_Title, message=locale.SourceSuccess_Text)
                else:
                    logcat("All resources founded.")

                return True
            else:
                if redownload_resources:
                    logcat("Some resources are missing. Clearing directory and re-downloading.")
                    for f in temp.listFiles():
                        if f.isFile():
                            f.delete()

                    threading.Thread(target=self.download_resources, args=(False,), daemon=True).start()

                return False

        except Exception as e:
            logcat(f"check_resources error: {e}")
            return False

    def download_resources(self, clear: bool):
        run_on_ui_thread(lambda: self.show_loading_alert("Downloading resources..."))

        temp = get_temp_dir()
        if not temp:
            logcat("Temp directory is none.")
            return

        if clear:
            for f in temp.listFiles():
                if f.isFile():
                    f.delete()

        progress: int = 0

        for r in RESOURCES:
            try:
                progress += 1
                run_on_ui_thread(lambda: self.update_loading_progress(progress))

                file_path = os.path.join(temp.getAbsolutePath(), r)
                url = DOWNLOAD_URL + f"resources/" + r

                download_file(url, file_path)

            except Exception as e:
                show_error(f"An unexpected error occurred while downloading {r}: {e}")
                logcat(f"An unexpected error occurred while downloading {r}: {e}")

        run_on_ui_thread(lambda: self.dismiss_loading_alert())

    def show_spinner(self):
        fragment = get_last_fragment()
        ctx = fragment.getParentActivity() if fragment else ApplicationLoader.applicationContext
        if ctx is None:
            logcat("Context not found, can't show spinner.")
            return

        self.spinner = AlertDialogBuilder(ctx, AlertDialogBuilder.ALERT_TYPE_SPINNER)
        self.spinner.set_cancelable(False)
        self.spinner.set_canceled_on_touch_outside(False)
        self.spinner.set_on_cancel_listener(None)
        self.spinner.create()
        self.spinner.show()

        if self.spinner.get_dialog() and self.spinner.get_dialog().isShowing():
            java = self.spinner.get_dialog()
            java.setCancelable(False)
            java.setCanceledOnTouchOutside(False)

    def dismiss_spinner(self):
        if self.spinner and self.spinner.get_dialog() and self.spinner.get_dialog().isShowing():
            self.spinner.dismiss()

        self.spinner = None

    def show_info_alert(self, title: str, message: str, positive_text: Optional[str] = None,
                        positive_listener: Optional[Callable] = None, neutral_text: Optional[str] = "Ok",
                        neutral_listener: Optional[Callable] = None):
        if title == "" or message == "":
            logcat("Title or message not found, can't show info alert.")
            return

        fragment = get_last_fragment()
        ctx = fragment.getParentActivity() if fragment else ApplicationLoader.applicationContext
        if ctx is None:
            logcat("Context not found, can't show info alert.")
            return

        self.info = AlertDialogBuilder(ctx, AlertDialogBuilder.ALERT_TYPE_MESSAGE)
        self.info.set_title(title)
        self.info.set_message(message)

        if positive_text:
            if positive_listener:
                self.info.set_positive_button(positive_text, lambda alert, i: positive_listener())
            else:
                self.info.set_positive_button(positive_text, lambda alert, i: self.dismiss_info_alert())

        if neutral_text:
            if neutral_listener:
                self.info.set_neutral_button(neutral_text, lambda alert, i: neutral_listener())
            else:
                self.info.set_neutral_button(neutral_text, lambda alert, i: self.dismiss_info_alert())

        self.info.show()

    def dismiss_info_alert(self):
        if self.info and self.info.get_dialog() and self.info.get_dialog().isShowing():
            self.info.dismiss()

        self.info = None

    def show_loading_alert(self, title: str):
        if title is None:
            logcat("Title is empty, can't show loading.")
            return

        fragment = get_last_fragment()
        ctx = fragment.getParentActivity() if fragment else ApplicationLoader.applicationContext
        if ctx is None:
            logcat("Context not found, can't show loading alert.")
            return

        self.loading = AlertDialogBuilder(ctx, AlertDialogBuilder.ALERT_TYPE_LOADING)
        self.loading.set_title(title)
        self.loading.set_cancelable(False)
        self.loading.set_canceled_on_touch_outside(False)
        self.loading.set_on_cancel_listener(None)
        self.loading.show()

        if self.loading.get_dialog() and self.loading.get_dialog().isShowing():
            java = self.loading.get_dialog()
            java.setCancelable(False)
            java.setCanceledOnTouchOutside(False)

        self.loading.set_progress(0)

    def update_loading_progress(self, progress: int):
        if self.loading is None or not self.loading.get_dialog().isShowing():
            logcat("Can't update loading alert, because he is None or not showing.")
            return

        self.loading.set_progress(progress)

    def dismiss_loading_alert(self):
        if self.loading and self.loading.get_dialog() and self.loading.get_dialog().isShowing():
            self.loading.dismiss()

        self.loading = None

"""



                            –î–ò–°–ö–õ–ï–ô–ú–ï–†

–ï—Å–ª–∏ –ø—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏ —Å–≤–æ–µ–≥–æ –ø–ª–∞–≥–∏–Ω–∞ –≤—ã —Ä–µ—à–∏–ª–∏ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –≥–æ—Ç–æ–≤—ã–µ –∫–æ–¥–æ–≤—ã–µ —Ä–µ—à–µ–Ω–∏—è
–Ω–∞—à–µ–≥–æ –ø–ª–∞–≥–∏–Ω–∞ —É —Å–µ–±—è, —Ç–æ –Ω–µ –∑–∞–±—É–¥—å—Ç–µ —É–ø–æ–º—è–Ω—É—Ç—å –≤ –æ–ø–∏—Å–∞–Ω–∏–∏ —Å–≤–æ–µ–≥–æ –ø–ª–∞–≥–∏–Ω–∞
–∫–∞–Ω–∞–ª @MeeowPlugins –≤ –∫–∞—á–µ—Å—Ç–≤–µ –∫—Ä–µ–¥–∏—Ç–æ–≤ –∑–∞ –ø–æ–º–æ—â—å –≤ —Ä–∞–∑—Ä–∞–±–æ—Ç–∫–µ –ø–ª–∞–≥–∏–Ω–∞. –°–ø–∞—Å–∏–±–æ


                  ‚£æ‚°á‚£ø‚£ø‚°á‚£æ‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£Ñ‚¢ª‚£¶‚°Ä‚†Å‚¢∏‚°å‚†ª‚£ø‚£ø‚£ø‚°Ω‚£ø‚£ø
                  ‚°á‚£ø‚†π‚£ø‚°á‚°ü‚†õ‚£â‚†Å‚†â‚†â‚†ª‚°ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£¶‚£Ñ‚°â‚†Ç‚†à‚†ô‚¢ø‚£ø‚£ù‚£ø
                  ‚†§‚¢ø‚°Ñ‚†π‚£ß‚£∑‚£∏‚°á‚†Ñ‚†Ñ‚†≤‚¢∞‚£å‚£æ‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£∂‚£§‚£§‚°Ä‚†Ñ‚†à‚†ª‚¢Æ
                  ‚†Ñ‚¢∏‚£ß‚†Ñ‚¢ò‚¢ª‚£ø‚°á‚¢Ä‚£Ä‚†Ñ‚£∏‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ß‚°Ä‚†Ñ‚¢Ä
                  ‚†Ñ‚†à‚£ø‚°Ü‚¢∏‚£ø‚£ø‚£ø‚£¨‚£≠‚£¥‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£Ø‚†ù‚†õ‚†õ‚†ô‚¢ø‚°ø‚†É‚†Ñ‚¢∏
                  ‚†Ñ‚†Ñ‚¢ø‚£ø‚°Ä‚£ø‚£ø‚£ø‚£æ‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£∑‚£ø‚£ø‚£ø‚£ø‚°æ‚†Å‚¢†‚°á‚¢Ä
                  ‚†Ñ‚†Ñ‚¢∏‚£ø‚°á‚†ª‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£è‚£´‚£ª‚°ü‚¢Ä‚†Ñ‚£ø‚£∑‚£æ
                  ‚†Ñ‚†Ñ‚¢∏‚£ø‚°á‚†Ñ‚†à‚†ô‚†ø‚£ø‚£ø‚£ø‚£Æ‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚°ø‚¢†‚†ä‚¢Ä‚°á‚£ø‚£ø
                  ‚†í‚†§‚†Ñ‚£ø‚°á‚¢Ä‚°≤‚†Ñ‚†Ñ‚†à‚†ô‚†ª‚¢ø‚£ø‚£ø‚†ø‚†ø‚†ü‚†õ‚†ã‚†Å‚£∞‚†á‚†Ñ‚¢∏‚£ø‚£ø‚£ø



                            DISCLAIMER

If, when creating your plugin, you decided to use the ready-made code solutions
of our plugin, then do not forget to mention the @MeeowPlugins channel in the description
of your plugin as credits for help in developing your plugin. Thanks



"""